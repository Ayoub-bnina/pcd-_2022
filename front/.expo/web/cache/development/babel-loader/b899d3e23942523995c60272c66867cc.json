{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nimport { Platform } from 'expo-modules-core';\nimport path from 'path-browserify';\nimport PixelRatio from \"react-native-web/dist/exports/PixelRatio\";\nimport URL from 'url-parse';\nimport AssetSourceResolver from \"./AssetSourceResolver\";\nimport { manifestBaseUrl, getManifest, getManifest2 } from \"./PlatformUtils\";\nvar assetMapOverride = getManifest().assetMapOverride;\nexport function selectAssetSource(meta) {\n  var _manifest2$extra, _manifest2$extra$expo;\n\n  if (assetMapOverride && assetMapOverride.hasOwnProperty(meta.hash)) {\n    meta = _objectSpread(_objectSpread({}, meta), assetMapOverride[meta.hash]);\n  }\n\n  var scale = AssetSourceResolver.pickScale(meta.scales, PixelRatio.get());\n  var index = meta.scales.findIndex(function (s) {\n    return s === scale;\n  });\n  var hash = meta.fileHashes ? meta.fileHashes[index] || meta.fileHashes[0] : meta.hash;\n  var uri = meta.fileUris ? meta.fileUris[index] || meta.fileUris[0] : meta.uri;\n\n  if (uri) {\n    return {\n      uri: resolveUri(uri),\n      hash: hash\n    };\n  }\n\n  var assetUrlOverride = getManifest().assetUrlOverride;\n\n  if (assetUrlOverride) {\n    var _uri = path.join(assetUrlOverride, hash);\n\n    return {\n      uri: resolveUri(_uri),\n      hash: hash\n    };\n  }\n\n  var fileScale = scale === 1 ? '' : \"@\" + scale + \"x\";\n  var fileExtension = meta.type ? \".\" + encodeURIComponent(meta.type) : '';\n  var suffix = \"/\" + encodeURIComponent(meta.name) + fileScale + fileExtension + \"?platform=\" + encodeURIComponent(Platform.OS) + \"&hash=\" + encodeURIComponent(meta.hash);\n\n  if (/^https?:\\/\\//.test(meta.httpServerLocation)) {\n    var _uri2 = meta.httpServerLocation + suffix;\n\n    return {\n      uri: _uri2,\n      hash: hash\n    };\n  }\n\n  var manifest2 = getManifest2();\n\n  if (manifest2 != null && (_manifest2$extra = manifest2.extra) != null && (_manifest2$extra$expo = _manifest2$extra.expoGo) != null && _manifest2$extra$expo.developer) {\n    var baseUrl = new URL(\"http://\" + manifest2.extra.expoGo.debuggerHost);\n    baseUrl.set('pathname', meta.httpServerLocation + suffix);\n    return {\n      uri: baseUrl.href,\n      hash: hash\n    };\n  }\n\n  if (getManifest().developer) {\n    var _baseUrl = new URL(getManifest().bundleUrl);\n\n    _baseUrl.set('pathname', meta.httpServerLocation + suffix);\n\n    return {\n      uri: _baseUrl.href,\n      hash: hash\n    };\n  }\n\n  return {\n    uri: \"https://d1wp6m56sqw74a.cloudfront.net/~assets/\" + encodeURIComponent(hash),\n    hash: hash\n  };\n}\nexport function resolveUri(uri) {\n  if (!manifestBaseUrl) {\n    return uri;\n  }\n\n  var _URL = new URL(uri),\n      protocol = _URL.protocol;\n\n  if (protocol !== '') {\n    return uri;\n  }\n\n  var baseUrl = new URL(manifestBaseUrl);\n  var resolvedPath = uri.startsWith('/') ? uri : path.join(baseUrl.pathname, uri);\n  baseUrl.set('pathname', resolvedPath);\n  return baseUrl.href;\n}","map":{"version":3,"mappings":"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","names":["Platform","path","URL","AssetSourceResolver","manifestBaseUrl","getManifest","getManifest2","assetMapOverride","selectAssetSource","meta","hasOwnProperty","hash","scale","pickScale","scales","PixelRatio","get","index","findIndex","s","fileHashes","uri","fileUris","resolveUri","assetUrlOverride","join","fileScale","fileExtension","type","encodeURIComponent","suffix","name","OS","test","httpServerLocation","manifest2","extra","expoGo","developer","baseUrl","debuggerHost","set","href","bundleUrl","protocol","resolvedPath","startsWith","pathname"],"sourceRoot":"","sources":["../src/AssetSources.ts"],"sourcesContent":["import { Platform } from 'expo-modules-core';\nimport path from 'path-browserify';\nimport { PixelRatio } from 'react-native';\nimport URL from 'url-parse';\n\nimport AssetSourceResolver from './AssetSourceResolver';\nimport { manifestBaseUrl, getManifest, getManifest2 } from './PlatformUtils';\n\n// @docsMissing\nexport type AssetMetadata = {\n  hash: string;\n  name: string;\n  type: string;\n  width?: number;\n  height?: number;\n  scales: number[];\n  httpServerLocation: string;\n  uri?: string;\n  fileHashes?: string[];\n  fileUris?: string[];\n};\n\nexport type AssetSource = {\n  uri: string;\n  hash: string;\n};\n\n// Fast lookup check if asset map has any overrides in the manifest\nconst assetMapOverride = getManifest().assetMapOverride;\n\n/**\n * Selects the best file for the given asset (ex: choosing the best scale for images) and returns\n * a { uri, hash } pair for the specific asset file.\n *\n * If the asset isn't an image with multiple scales, the first file is selected.\n */\nexport function selectAssetSource(meta: AssetMetadata): AssetSource {\n  // Override with the asset map in manifest if available\n  if (assetMapOverride && assetMapOverride.hasOwnProperty(meta.hash)) {\n    meta = { ...meta, ...assetMapOverride[meta.hash] };\n  }\n\n  // This logic is based on that of AssetSourceResolver, with additional support for file hashes and\n  // explicitly provided URIs\n  const scale = AssetSourceResolver.pickScale(meta.scales, PixelRatio.get());\n  const index = meta.scales.findIndex((s) => s === scale);\n  const hash = meta.fileHashes ? meta.fileHashes[index] || meta.fileHashes[0] : meta.hash;\n\n  // Allow asset processors to directly provide the URL to load\n  const uri = meta.fileUris ? meta.fileUris[index] || meta.fileUris[0] : meta.uri;\n  if (uri) {\n    return { uri: resolveUri(uri), hash };\n  }\n\n  // Check if the assetUrl was overridden in the manifest\n  const assetUrlOverride = getManifest().assetUrlOverride;\n  if (assetUrlOverride) {\n    const uri = path.join(assetUrlOverride, hash);\n    return { uri: resolveUri(uri), hash };\n  }\n\n  const fileScale = scale === 1 ? '' : `@${scale}x`;\n  const fileExtension = meta.type ? `.${encodeURIComponent(meta.type)}` : '';\n  const suffix = `/${encodeURIComponent(\n    meta.name\n  )}${fileScale}${fileExtension}?platform=${encodeURIComponent(\n    Platform.OS\n  )}&hash=${encodeURIComponent(meta.hash)}`;\n\n  // For assets with a specified absolute URL, we use the existing origin instead of prepending the\n  // development server or production CDN URL origin\n  if (/^https?:\\/\\//.test(meta.httpServerLocation)) {\n    const uri = meta.httpServerLocation + suffix;\n    return { uri, hash };\n  }\n\n  // For assets during development using manifest2, we use the development server's URL origin\n  const manifest2 = getManifest2();\n\n  if (manifest2?.extra?.expoGo?.developer) {\n    const baseUrl = new URL(`http://${manifest2.extra.expoGo.debuggerHost}`);\n    baseUrl.set('pathname', meta.httpServerLocation + suffix);\n\n    return {\n      uri: baseUrl.href,\n      hash,\n    };\n  }\n\n  // For assets during development, we use the development server's URL origin\n  if (getManifest().developer) {\n    const baseUrl = new URL(getManifest().bundleUrl);\n    baseUrl.set('pathname', meta.httpServerLocation + suffix);\n    return { uri: baseUrl.href, hash };\n  }\n\n  // Production CDN URIs are based on each asset file hash\n  return {\n    uri: `https://d1wp6m56sqw74a.cloudfront.net/~assets/${encodeURIComponent(hash)}`,\n    hash,\n  };\n}\n\n/**\n * Resolves the given URI to an absolute URI. If the given URI is already an absolute URI, it is\n * simply returned. Otherwise, if it is a relative URI, it is resolved relative to the manifest's\n * base URI.\n */\nexport function resolveUri(uri: string): string {\n  if (!manifestBaseUrl) {\n    return uri;\n  }\n\n  const { protocol } = new URL(uri);\n  if (protocol !== '') {\n    return uri;\n  }\n\n  const baseUrl = new URL(manifestBaseUrl);\n  const resolvedPath = uri.startsWith('/') ? uri : path.join(baseUrl.pathname, uri);\n  baseUrl.set('pathname', resolvedPath);\n  return baseUrl.href;\n}\n"]},"metadata":{},"sourceType":"module"}