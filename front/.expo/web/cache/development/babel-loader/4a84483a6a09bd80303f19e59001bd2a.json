{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport * as React from 'react';\nimport TextInput from \"react-native-web/dist/exports/TextInput\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport Keyboard from \"react-native-web/dist/exports/Keyboard\";\n\nvar KeyboardManager = function (_React$Component) {\n  _inherits(KeyboardManager, _React$Component);\n\n  var _super = _createSuper(KeyboardManager);\n\n  function KeyboardManager() {\n    var _this;\n\n    _classCallCheck(this, KeyboardManager);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n\n    _defineProperty(_assertThisInitialized(_this), \"previouslyFocusedTextInput\", null);\n\n    _defineProperty(_assertThisInitialized(_this), \"startTimestamp\", 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"keyboardTimeout\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"clearKeyboardTimeout\", function () {\n      if (_this.keyboardTimeout !== undefined) {\n        clearTimeout(_this.keyboardTimeout);\n        _this.keyboardTimeout = undefined;\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handlePageChangeStart\", function () {\n      if (!_this.props.enabled) {\n        return;\n      }\n\n      _this.clearKeyboardTimeout();\n\n      var input = TextInput.State.currentlyFocusedInput ? TextInput.State.currentlyFocusedInput() : TextInput.State.currentlyFocusedField();\n      TextInput.State.blurTextInput(input);\n      _this.previouslyFocusedTextInput = input;\n      _this.startTimestamp = Date.now();\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handlePageChangeConfirm\", function () {\n      if (!_this.props.enabled) {\n        return;\n      }\n\n      _this.clearKeyboardTimeout();\n\n      var input = _this.previouslyFocusedTextInput;\n\n      if (Platform.OS === 'android') {\n        Keyboard.dismiss();\n      } else if (input) {\n        TextInput.State.blurTextInput(input);\n      }\n\n      _this.previouslyFocusedTextInput = null;\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handlePageChangeCancel\", function () {\n      if (!_this.props.enabled) {\n        return;\n      }\n\n      _this.clearKeyboardTimeout();\n\n      var input = _this.previouslyFocusedTextInput;\n\n      if (input) {\n        if (Date.now() - _this.startTimestamp < 100) {\n          _this.keyboardTimeout = setTimeout(function () {\n            TextInput.State.focusTextInput(input);\n            _this.previouslyFocusedTextInput = null;\n          }, 100);\n        } else {\n          TextInput.State.focusTextInput(input);\n          _this.previouslyFocusedTextInput = null;\n        }\n      }\n    });\n\n    return _this;\n  }\n\n  _createClass(KeyboardManager, [{\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.clearKeyboardTimeout();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return this.props.children({\n        onPageChangeStart: this.handlePageChangeStart,\n        onPageChangeConfirm: this.handlePageChangeConfirm,\n        onPageChangeCancel: this.handlePageChangeCancel\n      });\n    }\n  }]);\n\n  return KeyboardManager;\n}(React.Component);\n\nexport { KeyboardManager as default };","map":{"version":3,"sources":["C:/LearnEZ/node_modules/react-navigation-stack/lib/module/vendor/views/KeyboardManager.js"],"names":["_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","React","KeyboardManager","args","keyboardTimeout","undefined","clearTimeout","props","enabled","clearKeyboardTimeout","input","TextInput","State","currentlyFocusedInput","currentlyFocusedField","blurTextInput","previouslyFocusedTextInput","startTimestamp","Date","now","Platform","OS","Keyboard","dismiss","setTimeout","focusTextInput","children","onPageChangeStart","handlePageChangeStart","onPageChangeConfirm","handlePageChangeConfirm","onPageChangeCancel","handlePageChangeCancel","Component"],"mappings":"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","sourcesContent":["function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport * as React from 'react';\nimport { TextInput, Platform, Keyboard } from 'react-native';\nexport default class KeyboardManager extends React.Component {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"previouslyFocusedTextInput\", null);\n\n    _defineProperty(this, \"startTimestamp\", 0);\n\n    _defineProperty(this, \"keyboardTimeout\", void 0);\n\n    _defineProperty(this, \"clearKeyboardTimeout\", () => {\n      if (this.keyboardTimeout !== undefined) {\n        clearTimeout(this.keyboardTimeout);\n        this.keyboardTimeout = undefined;\n      }\n    });\n\n    _defineProperty(this, \"handlePageChangeStart\", () => {\n      if (!this.props.enabled) {\n        return;\n      }\n\n      this.clearKeyboardTimeout(); // @ts-expect-error: currentlyFocusedInput is pretty new, so not in the type definitions\n\n      const input = TextInput.State.currentlyFocusedInput ? // @ts-expect-error\n      TextInput.State.currentlyFocusedInput() : TextInput.State.currentlyFocusedField(); // When a page change begins, blur the currently focused input\n\n      TextInput.State.blurTextInput(input); // Store the id of this input so we can refocus it if change was cancelled\n\n      this.previouslyFocusedTextInput = input; // Store timestamp for touch start\n\n      this.startTimestamp = Date.now();\n    });\n\n    _defineProperty(this, \"handlePageChangeConfirm\", () => {\n      if (!this.props.enabled) {\n        return;\n      }\n\n      this.clearKeyboardTimeout();\n      const input = this.previouslyFocusedTextInput;\n\n      if (Platform.OS === 'android') {\n        Keyboard.dismiss();\n      } else if (input) {\n        TextInput.State.blurTextInput(input);\n      } // Cleanup the ID on successful page change\n\n\n      this.previouslyFocusedTextInput = null;\n    });\n\n    _defineProperty(this, \"handlePageChangeCancel\", () => {\n      if (!this.props.enabled) {\n        return;\n      }\n\n      this.clearKeyboardTimeout(); // The page didn't change, we should restore the focus of text input\n\n      const input = this.previouslyFocusedTextInput;\n\n      if (input) {\n        // If the interaction was super short we should make sure keyboard won't hide again.\n        // Too fast input refocus will result only in keyboard flashing on screen and hiding right away.\n        // During first ~100ms keyboard will be dismissed no matter what,\n        // so we have to make sure it won't interrupt input refocus logic.\n        // That's why when the interaction is shorter than 100ms we add delay so it won't hide once again.\n        // Subtracting timestamps makes us sure the delay is executed only when needed.\n        if (Date.now() - this.startTimestamp < 100) {\n          this.keyboardTimeout = setTimeout(() => {\n            TextInput.State.focusTextInput(input);\n            this.previouslyFocusedTextInput = null;\n          }, 100);\n        } else {\n          TextInput.State.focusTextInput(input);\n          this.previouslyFocusedTextInput = null;\n        }\n      }\n    });\n  }\n\n  componentWillUnmount() {\n    this.clearKeyboardTimeout();\n  } // Numeric id of the previously focused text input\n  // When a gesture didn't change the tab, we can restore the focused input with this\n\n\n  render() {\n    return this.props.children({\n      onPageChangeStart: this.handlePageChangeStart,\n      onPageChangeConfirm: this.handlePageChangeConfirm,\n      onPageChangeCancel: this.handlePageChangeCancel\n    });\n  }\n\n}\n//# sourceMappingURL=KeyboardManager.js.map"]},"metadata":{},"sourceType":"module"}