{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport invariant from \"../utils/invariant\";\nimport getScreenForRouteName from \"./getScreenForRouteName\";\nimport createConfigGetter from \"./createConfigGetter\";\nimport * as NavigationActions from \"../NavigationActions\";\nimport * as SwitchActions from \"./SwitchActions\";\nimport * as StackActions from \"./StackActions\";\nimport validateRouteConfigMap from \"./validateRouteConfigMap\";\nimport { createPathParser } from \"./pathUtils\";\n\nvar defaultActionCreators = function defaultActionCreators() {\n  return {};\n};\n\nexport default (function (routeConfigs) {\n  var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  validateRouteConfigMap(routeConfigs);\n  var order = config.order || Object.keys(routeConfigs);\n  var getCustomActionCreators = config.getCustomActionCreators || defaultActionCreators;\n  var initialRouteParams = config.initialRouteParams;\n  var initialRouteName = config.initialRouteName || order[0];\n  var backBehavior = config.backBehavior || 'none';\n  var resetOnBlur = config.hasOwnProperty('resetOnBlur') ? config.resetOnBlur : true;\n  var initialRouteIndex = order.indexOf(initialRouteName);\n\n  if (initialRouteIndex === -1) {\n    throw new Error(\"Invalid initialRouteName '\".concat(initialRouteName, \"'.\") + \"Should be one of \".concat(order.map(function (n) {\n      return \"\\\"\".concat(n, \"\\\"\");\n    }).join(', ')));\n  }\n\n  var childRouters = {};\n  order.forEach(function (routeName) {\n    childRouters[routeName] = null;\n    var screen = getScreenForRouteName(routeConfigs, routeName);\n\n    if (screen.router) {\n      childRouters[routeName] = screen.router;\n    }\n  });\n\n  function getParamsForRoute(routeName, params) {\n    var routeConfig = routeConfigs[routeName];\n\n    if (routeConfig && routeConfig.params) {\n      return _objectSpread({}, routeConfig.params, {}, params);\n    } else {\n      return params;\n    }\n  }\n\n  var _createPathParser = createPathParser(childRouters, routeConfigs, config),\n      getPathAndParamsForRoute = _createPathParser.getPathAndParamsForRoute,\n      _getActionForPathAndParams = _createPathParser.getActionForPathAndParams;\n\n  function resetChildRoute(routeName) {\n    var initialParams = routeName === initialRouteName ? initialRouteParams : undefined;\n    var params = getParamsForRoute(routeName, initialParams);\n    var childRouter = childRouters[routeName];\n\n    if (childRouter) {\n      var childAction = NavigationActions.init();\n      return _objectSpread({}, childRouter.getStateForAction(childAction), {\n        key: routeName,\n        routeName: routeName,\n        params: params\n      });\n    }\n\n    return {\n      key: routeName,\n      routeName: routeName,\n      params: params\n    };\n  }\n\n  function getNextState(action, prevState, possibleNextState) {\n    function updateNextStateHistory(prevState, nextState) {\n      if (backBehavior !== 'history' || prevState && nextState && nextState.index === prevState.index) {\n        return nextState;\n      }\n\n      var nextRouteKeyHistory = prevState ? prevState.routeKeyHistory : [];\n\n      if (action.type === NavigationActions.NAVIGATE) {\n        nextRouteKeyHistory = _toConsumableArray(nextRouteKeyHistory);\n        var keyToAdd = nextState.routes[nextState.index].key;\n        nextRouteKeyHistory = nextRouteKeyHistory.filter(function (k) {\n          return k !== keyToAdd;\n        });\n        nextRouteKeyHistory.push(keyToAdd);\n      } else if (action.type === NavigationActions.BACK) {\n        nextRouteKeyHistory = _toConsumableArray(nextRouteKeyHistory);\n        nextRouteKeyHistory.pop();\n      }\n\n      return _objectSpread({}, nextState, {\n        routeKeyHistory: nextRouteKeyHistory\n      });\n    }\n\n    var nextState = possibleNextState;\n\n    if (prevState && possibleNextState && prevState.index !== possibleNextState.index && resetOnBlur) {\n      var prevRouteName = prevState.routes[prevState.index].routeName;\n\n      var nextRoutes = _toConsumableArray(possibleNextState.routes);\n\n      nextRoutes[prevState.index] = resetChildRoute(prevRouteName);\n      nextState = _objectSpread({}, possibleNextState, {\n        routes: nextRoutes\n      });\n    }\n\n    return updateNextStateHistory(prevState, nextState);\n  }\n\n  function getInitialState() {\n    var routes = order.map(resetChildRoute);\n    var initialState = {\n      routes: routes,\n      index: initialRouteIndex\n    };\n\n    if (backBehavior === 'history') {\n      var initialKey = routes[initialRouteIndex].key;\n      initialState['routeKeyHistory'] = [initialKey];\n    }\n\n    return initialState;\n  }\n\n  return {\n    childRouters: childRouters,\n    getActionCreators: function getActionCreators(route, stateKey) {\n      return getCustomActionCreators(route, stateKey);\n    },\n    getStateForAction: function getStateForAction(action, inputState) {\n      var prevState = inputState ? _objectSpread({}, inputState) : inputState;\n      var state = inputState || getInitialState();\n      var activeChildIndex = state.index;\n\n      if (action.type === NavigationActions.INIT) {\n        var params = action.params;\n\n        if (params) {\n          state.routes = state.routes.map(function (route) {\n            return _objectSpread({}, route, {\n              params: _objectSpread({}, route.params, {}, params, {}, route.routeName === initialRouteName ? initialRouteParams : null)\n            });\n          });\n        }\n      }\n\n      if (action.type === SwitchActions.JUMP_TO && (action.key == null || action.key === state.key)) {\n        var _params = action.params;\n        var index = state.routes.findIndex(function (route) {\n          return route.routeName === action.routeName;\n        });\n\n        if (index === -1) {\n          throw new Error(\"There is no route named '\".concat(action.routeName, \"' in the navigator with the key '\").concat(action.key, \"'.\\n\") + \"Must be one of: \".concat(state.routes.map(function (route) {\n            return \"'\".concat(route.routeName, \"'\");\n          }).join(',')));\n        }\n\n        return getNextState(action, prevState, _objectSpread({}, state, {\n          routes: _params ? state.routes.map(function (route, i) {\n            return i === index ? _objectSpread({}, route, {\n              params: _objectSpread({}, route.params, {}, _params)\n            }) : route;\n          }) : state.routes,\n          index: index\n        }));\n      }\n\n      var activeChildLastState = state.routes[state.index];\n      var activeChildRouter = childRouters[order[state.index]];\n\n      if (activeChildRouter) {\n        var activeChildState = activeChildRouter.getStateForAction(action, activeChildLastState);\n\n        if (!activeChildState && inputState) {\n          return null;\n        }\n\n        if (activeChildState && activeChildState !== activeChildLastState) {\n          var routes = _toConsumableArray(state.routes);\n\n          routes[state.index] = activeChildState;\n          return getNextState(action, prevState, _objectSpread({}, state, {\n            routes: routes\n          }));\n        }\n      }\n\n      var isBackEligible = action.key == null || action.key === activeChildLastState.key;\n\n      if (action.type === NavigationActions.BACK) {\n        if (isBackEligible && backBehavior === 'initialRoute') {\n          activeChildIndex = initialRouteIndex;\n        } else if (isBackEligible && backBehavior === 'order') {\n          activeChildIndex = Math.max(0, activeChildIndex - 1);\n        } else if (isBackEligible && backBehavior === 'history' && state.routeKeyHistory.length > 1) {\n          var routeKey = state.routeKeyHistory[state.routeKeyHistory.length - 2];\n          activeChildIndex = order.indexOf(routeKey);\n        }\n      }\n\n      var didNavigate = false;\n\n      if (action.type === NavigationActions.NAVIGATE) {\n        didNavigate = !!order.find(function (childId, i) {\n          if (childId === action.routeName) {\n            activeChildIndex = i;\n            return true;\n          }\n\n          return false;\n        });\n\n        if (didNavigate) {\n          var childState = state.routes[activeChildIndex];\n          var childRouter = childRouters[action.routeName];\n          var newChildState = childState;\n\n          if (action.action && childRouter) {\n            var childStateUpdate = childRouter.getStateForAction(action.action, childState);\n\n            if (childStateUpdate) {\n              newChildState = childStateUpdate;\n            }\n          }\n\n          if (action.params) {\n            newChildState = _objectSpread({}, newChildState, {\n              params: _objectSpread({}, newChildState.params || {}, {}, action.params)\n            });\n          }\n\n          if (newChildState !== childState) {\n            var _routes = _toConsumableArray(state.routes);\n\n            _routes[activeChildIndex] = newChildState;\n\n            var nextState = _objectSpread({}, state, {\n              routes: _routes,\n              index: activeChildIndex\n            });\n\n            return getNextState(action, prevState, nextState);\n          } else if (newChildState === childState && state.index === activeChildIndex && prevState) {\n            return null;\n          }\n        }\n      }\n\n      if (action.type === NavigationActions.SET_PARAMS) {\n        var key = action.key;\n        var lastRoute = state.routes.find(function (route) {\n          return route.key === key;\n        });\n\n        if (lastRoute) {\n          var _params2 = _objectSpread({}, lastRoute.params, {}, action.params);\n\n          var _routes2 = _toConsumableArray(state.routes);\n\n          _routes2[state.routes.indexOf(lastRoute)] = _objectSpread({}, lastRoute, {\n            params: _params2\n          });\n          return getNextState(action, prevState, _objectSpread({}, state, {\n            routes: _routes2\n          }));\n        }\n      }\n\n      if (activeChildIndex !== state.index) {\n        return getNextState(action, prevState, _objectSpread({}, state, {\n          index: activeChildIndex\n        }));\n      } else if (didNavigate && !inputState) {\n        return state;\n      } else if (didNavigate) {\n        return _objectSpread({}, state);\n      }\n\n      var isActionBackOrPop = action.type === NavigationActions.BACK || action.type === StackActions.POP || action.type === StackActions.POP_TO_TOP;\n      var sendActionToInactiveChildren = !isActionBackOrPop || action.type === NavigationActions.BACK && action.key != null;\n\n      if (sendActionToInactiveChildren) {\n        var _index = state.index;\n        var _routes3 = state.routes;\n        order.find(function (childId, i) {\n          var childRouter = childRouters[childId];\n\n          if (i === _index) {\n            return false;\n          }\n\n          var childState = _routes3[i];\n\n          if (childRouter) {\n            childState = childRouter.getStateForAction(action, childState);\n          }\n\n          if (!childState) {\n            _index = i;\n            return true;\n          }\n\n          if (childState !== _routes3[i]) {\n            _routes3 = _toConsumableArray(_routes3);\n            _routes3[i] = childState;\n            _index = i;\n            return true;\n          }\n\n          return false;\n        });\n\n        if (action.preserveFocus) {\n          _index = state.index;\n        }\n\n        if (_index !== state.index || _routes3 !== state.routes) {\n          return getNextState(action, prevState, _objectSpread({}, state, {\n            index: _index,\n            routes: _routes3\n          }));\n        }\n      }\n\n      return state;\n    },\n    getComponentForState: function getComponentForState(state) {\n      var routeName = state.routes[state.index].routeName;\n      invariant(routeName, \"There is no route defined for index \".concat(state.index, \". Check that\\n        that you passed in a navigation state with a valid tab/screen index.\"));\n      var childRouter = childRouters[routeName];\n\n      if (childRouter) {\n        return childRouter.getComponentForState(state.routes[state.index]);\n      }\n\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n    getComponentForRouteName: function getComponentForRouteName(routeName) {\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n    getPathAndParamsForState: function getPathAndParamsForState(state) {\n      var route = state.routes[state.index];\n      return getPathAndParamsForRoute(route);\n    },\n    getActionForPathAndParams: function getActionForPathAndParams(path, params) {\n      return _getActionForPathAndParams(path, params);\n    },\n    getScreenOptions: createConfigGetter(routeConfigs, config.defaultNavigationOptions)\n  };\n});","map":{"version":3,"sources":["C:/LearnEZ/node_modules/@react-navigation/core/lib/module/routers/SwitchRouter.js"],"names":["ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","obj","value","configurable","writable","invariant","getScreenForRouteName","createConfigGetter","NavigationActions","SwitchActions","StackActions","validateRouteConfigMap","createPathParser","defaultActionCreators","routeConfigs","config","order","getCustomActionCreators","initialRouteParams","initialRouteName","backBehavior","resetOnBlur","hasOwnProperty","initialRouteIndex","indexOf","Error","concat","map","n","join","childRouters","routeName","screen","router","getParamsForRoute","params","routeConfig","getPathAndParamsForRoute","getActionForPathAndParams","resetChildRoute","initialParams","undefined","childRouter","childAction","init","getStateForAction","getNextState","action","prevState","possibleNextState","updateNextStateHistory","nextState","index","nextRouteKeyHistory","routeKeyHistory","type","NAVIGATE","keyToAdd","routes","k","BACK","pop","prevRouteName","nextRoutes","getInitialState","initialState","initialKey","getActionCreators","route","stateKey","inputState","state","activeChildIndex","INIT","JUMP_TO","findIndex","activeChildLastState","activeChildRouter","activeChildState","isBackEligible","Math","max","routeKey","didNavigate","find","childId","childState","newChildState","childStateUpdate","SET_PARAMS","lastRoute","isActionBackOrPop","POP","POP_TO_TOP","sendActionToInactiveChildren","preserveFocus","getComponentForState","getComponentForRouteName","getPathAndParamsForState","path","getScreenOptions","defaultNavigationOptions"],"mappings":";;AAAA,SAASA,OAAT,CAAiBC,MAAjB,EAAyBC,cAAzB,EAAyC;AAAE,MAAIC,IAAI,GAAGC,MAAM,CAACD,IAAP,CAAYF,MAAZ,CAAX;;AAAgC,MAAIG,MAAM,CAACC,qBAAX,EAAkC;AAAE,QAAIC,OAAO,GAAGF,MAAM,CAACC,qBAAP,CAA6BJ,MAA7B,CAAd;AAAoD,QAAIC,cAAJ,EAAoBI,OAAO,GAAGA,OAAO,CAACC,MAAR,CAAe,UAAUC,GAAV,EAAe;AAAE,aAAOJ,MAAM,CAACK,wBAAP,CAAgCR,MAAhC,EAAwCO,GAAxC,EAA6CE,UAApD;AAAiE,KAAjG,CAAV;AAA8GP,IAAAA,IAAI,CAACQ,IAAL,CAAUC,KAAV,CAAgBT,IAAhB,EAAsBG,OAAtB;AAAiC;;AAAC,SAAOH,IAAP;AAAc;;AAErV,SAASU,aAAT,CAAuBC,MAAvB,EAA+B;AAAE,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGC,SAAS,CAACC,MAA9B,EAAsCF,CAAC,EAAvC,EAA2C;AAAE,QAAIG,MAAM,GAAGF,SAAS,CAACD,CAAD,CAAT,IAAgB,IAAhB,GAAuBC,SAAS,CAACD,CAAD,CAAhC,GAAsC,EAAnD;;AAAuD,QAAIA,CAAC,GAAG,CAAR,EAAW;AAAEf,MAAAA,OAAO,CAACI,MAAM,CAACc,MAAD,CAAP,EAAiB,IAAjB,CAAP,CAA8BC,OAA9B,CAAsC,UAAUC,GAAV,EAAe;AAAEC,QAAAA,eAAe,CAACP,MAAD,EAASM,GAAT,EAAcF,MAAM,CAACE,GAAD,CAApB,CAAf;AAA4C,OAAnG;AAAuG,KAApH,MAA0H,IAAIhB,MAAM,CAACkB,yBAAX,EAAsC;AAAElB,MAAAA,MAAM,CAACmB,gBAAP,CAAwBT,MAAxB,EAAgCV,MAAM,CAACkB,yBAAP,CAAiCJ,MAAjC,CAAhC;AAA4E,KAApH,MAA0H;AAAElB,MAAAA,OAAO,CAACI,MAAM,CAACc,MAAD,CAAP,CAAP,CAAwBC,OAAxB,CAAgC,UAAUC,GAAV,EAAe;AAAEhB,QAAAA,MAAM,CAACoB,cAAP,CAAsBV,MAAtB,EAA8BM,GAA9B,EAAmChB,MAAM,CAACK,wBAAP,CAAgCS,MAAhC,EAAwCE,GAAxC,CAAnC;AAAmF,OAApI;AAAwI;AAAE;;AAAC,SAAON,MAAP;AAAgB;;AAEthB,SAASO,eAAT,CAAyBI,GAAzB,EAA8BL,GAA9B,EAAmCM,KAAnC,EAA0C;AAAE,MAAIN,GAAG,IAAIK,GAAX,EAAgB;AAAErB,IAAAA,MAAM,CAACoB,cAAP,CAAsBC,GAAtB,EAA2BL,GAA3B,EAAgC;AAAEM,MAAAA,KAAK,EAAEA,KAAT;AAAgBhB,MAAAA,UAAU,EAAE,IAA5B;AAAkCiB,MAAAA,YAAY,EAAE,IAAhD;AAAsDC,MAAAA,QAAQ,EAAE;AAAhE,KAAhC;AAA0G,GAA5H,MAAkI;AAAEH,IAAAA,GAAG,CAACL,GAAD,CAAH,GAAWM,KAAX;AAAmB;;AAAC,SAAOD,GAAP;AAAa;;AAEjN,OAAOI,SAAP;AACA,OAAOC,qBAAP;AACA,OAAOC,kBAAP;AACA,OAAO,KAAKC,iBAAZ;AACA,OAAO,KAAKC,aAAZ;AACA,OAAO,KAAKC,YAAZ;AACA,OAAOC,sBAAP;AACA,SAASC,gBAAT;;AAEA,IAAMC,qBAAqB,GAAG,SAAxBA,qBAAwB;AAAA,SAAO,EAAP;AAAA,CAA9B;;AAEA,gBAAgB,UAACC,YAAD,EAA+B;AAAA,MAAhBC,MAAgB,uEAAP,EAAO;AAE7CJ,EAAAA,sBAAsB,CAACG,YAAD,CAAtB;AACA,MAAME,KAAK,GAAGD,MAAM,CAACC,KAAP,IAAgBpC,MAAM,CAACD,IAAP,CAAYmC,YAAZ,CAA9B;AACA,MAAMG,uBAAuB,GAAGF,MAAM,CAACE,uBAAP,IAAkCJ,qBAAlE;AACA,MAAMK,kBAAkB,GAAGH,MAAM,CAACG,kBAAlC;AACA,MAAMC,gBAAgB,GAAGJ,MAAM,CAACI,gBAAP,IAA2BH,KAAK,CAAC,CAAD,CAAzD;AACA,MAAMI,YAAY,GAAGL,MAAM,CAACK,YAAP,IAAuB,MAA5C;AACA,MAAMC,WAAW,GAAGN,MAAM,CAACO,cAAP,CAAsB,aAAtB,IAAuCP,MAAM,CAACM,WAA9C,GAA4D,IAAhF;AACA,MAAME,iBAAiB,GAAGP,KAAK,CAACQ,OAAN,CAAcL,gBAAd,CAA1B;;AAEA,MAAII,iBAAiB,KAAK,CAAC,CAA3B,EAA8B;AAC5B,UAAM,IAAIE,KAAJ,CAAU,6BAA6BC,MAA7B,CAAoCP,gBAApC,EAAsD,IAAtD,IAA8D,oBAAoBO,MAApB,CAA2BV,KAAK,CAACW,GAAN,CAAU,UAAAC,CAAC;AAAA,aAAI,KAAKF,MAAL,CAAYE,CAAZ,EAAe,IAAf,CAAJ;AAAA,KAAX,EAAqCC,IAArC,CAA0C,IAA1C,CAA3B,CAAxE,CAAN;AACD;;AAED,MAAMC,YAAY,GAAG,EAArB;AACAd,EAAAA,KAAK,CAACrB,OAAN,CAAc,UAAAoC,SAAS,EAAI;AACzBD,IAAAA,YAAY,CAACC,SAAD,CAAZ,GAA0B,IAA1B;AACA,QAAMC,MAAM,GAAG1B,qBAAqB,CAACQ,YAAD,EAAeiB,SAAf,CAApC;;AAEA,QAAIC,MAAM,CAACC,MAAX,EAAmB;AACjBH,MAAAA,YAAY,CAACC,SAAD,CAAZ,GAA0BC,MAAM,CAACC,MAAjC;AACD;AACF,GAPD;;AASA,WAASC,iBAAT,CAA2BH,SAA3B,EAAsCI,MAAtC,EAA8C;AAC5C,QAAIC,WAAW,GAAGtB,YAAY,CAACiB,SAAD,CAA9B;;AAEA,QAAIK,WAAW,IAAIA,WAAW,CAACD,MAA/B,EAAuC;AACrC,aAAO9C,aAAa,CAAC,EAAD,EAAK+C,WAAW,CAACD,MAAjB,EAAyB,EAAzB,EAA6BA,MAA7B,CAApB;AACD,KAFD,MAEO;AACL,aAAOA,MAAP;AACD;AACF;;AAED,0BAGIvB,gBAAgB,CAACkB,YAAD,EAAehB,YAAf,EAA6BC,MAA7B,CAHpB;AAAA,MACEsB,wBADF,qBACEA,wBADF;AAAA,MAEEC,0BAFF,qBAEEA,yBAFF;;AAKA,WAASC,eAAT,CAAyBR,SAAzB,EAAoC;AAClC,QAAIS,aAAa,GAAGT,SAAS,KAAKZ,gBAAd,GAAiCD,kBAAjC,GAAsDuB,SAA1E;AAIA,QAAIN,MAAM,GAAGD,iBAAiB,CAACH,SAAD,EAAYS,aAAZ,CAA9B;AACA,QAAME,WAAW,GAAGZ,YAAY,CAACC,SAAD,CAAhC;;AAEA,QAAIW,WAAJ,EAAiB;AACf,UAAMC,WAAW,GAAGnC,iBAAiB,CAACoC,IAAlB,EAApB;AACA,aAAOvD,aAAa,CAAC,EAAD,EAAKqD,WAAW,CAACG,iBAAZ,CAA8BF,WAA9B,CAAL,EAAiD;AACnE/C,QAAAA,GAAG,EAAEmC,SAD8D;AAEnEA,QAAAA,SAAS,EAATA,SAFmE;AAGnEI,QAAAA,MAAM,EAANA;AAHmE,OAAjD,CAApB;AAKD;;AAED,WAAO;AACLvC,MAAAA,GAAG,EAAEmC,SADA;AAELA,MAAAA,SAAS,EAATA,SAFK;AAGLI,MAAAA,MAAM,EAANA;AAHK,KAAP;AAKD;;AAED,WAASW,YAAT,CAAsBC,MAAtB,EAA8BC,SAA9B,EAAyCC,iBAAzC,EAA4D;AAC1D,aAASC,sBAAT,CAAgCF,SAAhC,EAA2CG,SAA3C,EAAsD;AACpD,UAAI/B,YAAY,KAAK,SAAjB,IAA8B4B,SAAS,IAAIG,SAAb,IAA0BA,SAAS,CAACC,KAAV,KAAoBJ,SAAS,CAACI,KAA1F,EAAiG;AAC/F,eAAOD,SAAP;AACD;;AAED,UAAIE,mBAAmB,GAAGL,SAAS,GAAGA,SAAS,CAACM,eAAb,GAA+B,EAAlE;;AAEA,UAAIP,MAAM,CAACQ,IAAP,KAAgB/C,iBAAiB,CAACgD,QAAtC,EAAgD;AAC9CH,QAAAA,mBAAmB,sBAAOA,mBAAP,CAAnB;AAEA,YAAMI,QAAQ,GAAGN,SAAS,CAACO,MAAV,CAAiBP,SAAS,CAACC,KAA3B,EAAkCxD,GAAnD;AACAyD,QAAAA,mBAAmB,GAAGA,mBAAmB,CAACtE,MAApB,CAA2B,UAAA4E,CAAC;AAAA,iBAAIA,CAAC,KAAKF,QAAV;AAAA,SAA5B,CAAtB;AAEAJ,QAAAA,mBAAmB,CAAClE,IAApB,CAAyBsE,QAAzB;AACD,OAPD,MAOO,IAAIV,MAAM,CAACQ,IAAP,KAAgB/C,iBAAiB,CAACoD,IAAtC,EAA4C;AACjDP,QAAAA,mBAAmB,sBAAOA,mBAAP,CAAnB;AAEAA,QAAAA,mBAAmB,CAACQ,GAApB;AACD;;AAED,aAAOxE,aAAa,CAAC,EAAD,EAAK8D,SAAL,EAAgB;AAClCG,QAAAA,eAAe,EAAED;AADiB,OAAhB,CAApB;AAGD;;AAED,QAAIF,SAAS,GAAGF,iBAAhB;;AAEA,QAAID,SAAS,IAAIC,iBAAb,IAAkCD,SAAS,CAACI,KAAV,KAAoBH,iBAAiB,CAACG,KAAxE,IAAiF/B,WAArF,EAAkG;AAChG,UAAMyC,aAAa,GAAGd,SAAS,CAACU,MAAV,CAAiBV,SAAS,CAACI,KAA3B,EAAkCrB,SAAxD;;AACA,UAAMgC,UAAU,sBAAOd,iBAAiB,CAACS,MAAzB,CAAhB;;AACAK,MAAAA,UAAU,CAACf,SAAS,CAACI,KAAX,CAAV,GAA8Bb,eAAe,CAACuB,aAAD,CAA7C;AACAX,MAAAA,SAAS,GAAG9D,aAAa,CAAC,EAAD,EAAK4D,iBAAL,EAAwB;AAC/CS,QAAAA,MAAM,EAAEK;AADuC,OAAxB,CAAzB;AAGD;;AAED,WAAOb,sBAAsB,CAACF,SAAD,EAAYG,SAAZ,CAA7B;AACD;;AAED,WAASa,eAAT,GAA2B;AACzB,QAAMN,MAAM,GAAG1C,KAAK,CAACW,GAAN,CAAUY,eAAV,CAAf;AACA,QAAM0B,YAAY,GAAG;AACnBP,MAAAA,MAAM,EAANA,MADmB;AAEnBN,MAAAA,KAAK,EAAE7B;AAFY,KAArB;;AAKA,QAAIH,YAAY,KAAK,SAArB,EAAgC;AAC9B,UAAM8C,UAAU,GAAGR,MAAM,CAACnC,iBAAD,CAAN,CAA0B3B,GAA7C;AACAqE,MAAAA,YAAY,CAAC,iBAAD,CAAZ,GAAkC,CAACC,UAAD,CAAlC;AACD;;AAED,WAAOD,YAAP;AACD;;AAED,SAAO;AACLnC,IAAAA,YAAY,EAAZA,YADK;AAGLqC,IAAAA,iBAHK,6BAGaC,KAHb,EAGoBC,QAHpB,EAG8B;AACjC,aAAOpD,uBAAuB,CAACmD,KAAD,EAAQC,QAAR,CAA9B;AACD,KALI;AAOLxB,IAAAA,iBAPK,6BAOaE,MAPb,EAOqBuB,UAPrB,EAOiC;AACpC,UAAItB,SAAS,GAAGsB,UAAU,GAAGjF,aAAa,CAAC,EAAD,EAAKiF,UAAL,CAAhB,GAAmCA,UAA7D;AACA,UAAIC,KAAK,GAAGD,UAAU,IAAIN,eAAe,EAAzC;AACA,UAAIQ,gBAAgB,GAAGD,KAAK,CAACnB,KAA7B;;AAEA,UAAIL,MAAM,CAACQ,IAAP,KAAgB/C,iBAAiB,CAACiE,IAAtC,EAA4C;AAK1C,YACEtC,MADF,GAEIY,MAFJ,CACEZ,MADF;;AAIA,YAAIA,MAAJ,EAAY;AACVoC,UAAAA,KAAK,CAACb,MAAN,GAAea,KAAK,CAACb,MAAN,CAAa/B,GAAb,CAAiB,UAAAyC,KAAK;AAAA,mBAAI/E,aAAa,CAAC,EAAD,EAAK+E,KAAL,EAAY;AAChEjC,cAAAA,MAAM,EAAE9C,aAAa,CAAC,EAAD,EAAK+E,KAAK,CAACjC,MAAX,EAAmB,EAAnB,EAAuBA,MAAvB,EAA+B,EAA/B,EAAmCiC,KAAK,CAACrC,SAAN,KAAoBZ,gBAApB,GAAuCD,kBAAvC,GAA4D,IAA/F;AAD2C,aAAZ,CAAjB;AAAA,WAAtB,CAAf;AAGD;AACF;;AAED,UAAI6B,MAAM,CAACQ,IAAP,KAAgB9C,aAAa,CAACiE,OAA9B,KAA0C3B,MAAM,CAACnD,GAAP,IAAc,IAAd,IAAsBmD,MAAM,CAACnD,GAAP,KAAe2E,KAAK,CAAC3E,GAArF,CAAJ,EAA+F;AAC7F,YACEuC,OADF,GAEIY,MAFJ,CACEZ,MADF;AAGA,YAAMiB,KAAK,GAAGmB,KAAK,CAACb,MAAN,CAAaiB,SAAb,CAAuB,UAAAP,KAAK;AAAA,iBAAIA,KAAK,CAACrC,SAAN,KAAoBgB,MAAM,CAAChB,SAA/B;AAAA,SAA5B,CAAd;;AAEA,YAAIqB,KAAK,KAAK,CAAC,CAAf,EAAkB;AAChB,gBAAM,IAAI3B,KAAJ,CAAU,4BAA4BC,MAA5B,CAAmCqB,MAAM,CAAChB,SAA1C,EAAqD,mCAArD,EAA0FL,MAA1F,CAAiGqB,MAAM,CAACnD,GAAxG,EAA6G,MAA7G,IAAuH,mBAAmB8B,MAAnB,CAA0B6C,KAAK,CAACb,MAAN,CAAa/B,GAAb,CAAiB,UAAAyC,KAAK;AAAA,mBAAI,IAAI1C,MAAJ,CAAW0C,KAAK,CAACrC,SAAjB,EAA4B,GAA5B,CAAJ;AAAA,WAAtB,EAA4DF,IAA5D,CAAiE,GAAjE,CAA1B,CAAjI,CAAN;AACD;;AAED,eAAOiB,YAAY,CAACC,MAAD,EAASC,SAAT,EAAoB3D,aAAa,CAAC,EAAD,EAAKkF,KAAL,EAAY;AAC9Db,UAAAA,MAAM,EAAEvB,OAAM,GAAGoC,KAAK,CAACb,MAAN,CAAa/B,GAAb,CAAiB,UAACyC,KAAD,EAAQ7E,CAAR;AAAA,mBAAcA,CAAC,KAAK6D,KAAN,GAAc/D,aAAa,CAAC,EAAD,EAAK+E,KAAL,EAAY;AACrFjC,cAAAA,MAAM,EAAE9C,aAAa,CAAC,EAAD,EAAK+E,KAAK,CAACjC,MAAX,EAAmB,EAAnB,EAAuBA,OAAvB;AADgE,aAAZ,CAA3B,GAE3CiC,KAF6B;AAAA,WAAjB,CAAH,GAEAG,KAAK,CAACb,MAH0C;AAI9DN,UAAAA,KAAK,EAALA;AAJ8D,SAAZ,CAAjC,CAAnB;AAMD;;AAGD,UAAMwB,oBAAoB,GAAGL,KAAK,CAACb,MAAN,CAAaa,KAAK,CAACnB,KAAnB,CAA7B;AACA,UAAMyB,iBAAiB,GAAG/C,YAAY,CAACd,KAAK,CAACuD,KAAK,CAACnB,KAAP,CAAN,CAAtC;;AAEA,UAAIyB,iBAAJ,EAAuB;AACrB,YAAMC,gBAAgB,GAAGD,iBAAiB,CAAChC,iBAAlB,CAAoCE,MAApC,EAA4C6B,oBAA5C,CAAzB;;AAEA,YAAI,CAACE,gBAAD,IAAqBR,UAAzB,EAAqC;AACnC,iBAAO,IAAP;AACD;;AAED,YAAIQ,gBAAgB,IAAIA,gBAAgB,KAAKF,oBAA7C,EAAmE;AACjE,cAAMlB,MAAM,sBAAOa,KAAK,CAACb,MAAb,CAAZ;;AACAA,UAAAA,MAAM,CAACa,KAAK,CAACnB,KAAP,CAAN,GAAsB0B,gBAAtB;AACA,iBAAOhC,YAAY,CAACC,MAAD,EAASC,SAAT,EAAoB3D,aAAa,CAAC,EAAD,EAAKkF,KAAL,EAAY;AAC9Db,YAAAA,MAAM,EAANA;AAD8D,WAAZ,CAAjC,CAAnB;AAGD;AACF;;AAID,UAAMqB,cAAc,GAAGhC,MAAM,CAACnD,GAAP,IAAc,IAAd,IAAsBmD,MAAM,CAACnD,GAAP,KAAegF,oBAAoB,CAAChF,GAAjF;;AAEA,UAAImD,MAAM,CAACQ,IAAP,KAAgB/C,iBAAiB,CAACoD,IAAtC,EAA4C;AAC1C,YAAImB,cAAc,IAAI3D,YAAY,KAAK,cAAvC,EAAuD;AACrDoD,UAAAA,gBAAgB,GAAGjD,iBAAnB;AACD,SAFD,MAEO,IAAIwD,cAAc,IAAI3D,YAAY,KAAK,OAAvC,EAAgD;AACrDoD,UAAAA,gBAAgB,GAAGQ,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYT,gBAAgB,GAAG,CAA/B,CAAnB;AACD,SAFM,MAIF,IAAIO,cAAc,IAAI3D,YAAY,KAAK,SAAnC,IAAgDmD,KAAK,CAACjB,eAAN,CAAsB7D,MAAtB,GAA+B,CAAnF,EAAsF;AACvF,cAAMyF,QAAQ,GAAGX,KAAK,CAACjB,eAAN,CAAsBiB,KAAK,CAACjB,eAAN,CAAsB7D,MAAtB,GAA+B,CAArD,CAAjB;AACA+E,UAAAA,gBAAgB,GAAGxD,KAAK,CAACQ,OAAN,CAAc0D,QAAd,CAAnB;AACD;AACJ;;AAED,UAAIC,WAAW,GAAG,KAAlB;;AAEA,UAAIpC,MAAM,CAACQ,IAAP,KAAgB/C,iBAAiB,CAACgD,QAAtC,EAAgD;AAC9C2B,QAAAA,WAAW,GAAG,CAAC,CAACnE,KAAK,CAACoE,IAAN,CAAW,UAACC,OAAD,EAAU9F,CAAV,EAAgB;AACzC,cAAI8F,OAAO,KAAKtC,MAAM,CAAChB,SAAvB,EAAkC;AAChCyC,YAAAA,gBAAgB,GAAGjF,CAAnB;AACA,mBAAO,IAAP;AACD;;AAED,iBAAO,KAAP;AACD,SAPe,CAAhB;;AASA,YAAI4F,WAAJ,EAAiB;AACf,cAAMG,UAAU,GAAGf,KAAK,CAACb,MAAN,CAAac,gBAAb,CAAnB;AACA,cAAM9B,WAAW,GAAGZ,YAAY,CAACiB,MAAM,CAAChB,SAAR,CAAhC;AACA,cAAIwD,aAAa,GAAGD,UAApB;;AAEA,cAAIvC,MAAM,CAACA,MAAP,IAAiBL,WAArB,EAAkC;AAChC,gBAAM8C,gBAAgB,GAAG9C,WAAW,CAACG,iBAAZ,CAA8BE,MAAM,CAACA,MAArC,EAA6CuC,UAA7C,CAAzB;;AAEA,gBAAIE,gBAAJ,EAAsB;AACpBD,cAAAA,aAAa,GAAGC,gBAAhB;AACD;AACF;;AAED,cAAIzC,MAAM,CAACZ,MAAX,EAAmB;AACjBoD,YAAAA,aAAa,GAAGlG,aAAa,CAAC,EAAD,EAAKkG,aAAL,EAAoB;AAC/CpD,cAAAA,MAAM,EAAE9C,aAAa,CAAC,EAAD,EAAKkG,aAAa,CAACpD,MAAd,IAAwB,EAA7B,EAAiC,EAAjC,EAAqCY,MAAM,CAACZ,MAA5C;AAD0B,aAApB,CAA7B;AAGD;;AAED,cAAIoD,aAAa,KAAKD,UAAtB,EAAkC;AAChC,gBAAM5B,OAAM,sBAAOa,KAAK,CAACb,MAAb,CAAZ;;AACAA,YAAAA,OAAM,CAACc,gBAAD,CAAN,GAA2Be,aAA3B;;AAEA,gBAAMpC,SAAS,GAAG9D,aAAa,CAAC,EAAD,EAAKkF,KAAL,EAAY;AACzCb,cAAAA,MAAM,EAANA,OADyC;AAEzCN,cAAAA,KAAK,EAAEoB;AAFkC,aAAZ,CAA/B;;AAKA,mBAAO1B,YAAY,CAACC,MAAD,EAASC,SAAT,EAAoBG,SAApB,CAAnB;AACD,WAVD,MAUO,IAAIoC,aAAa,KAAKD,UAAlB,IAAgCf,KAAK,CAACnB,KAAN,KAAgBoB,gBAAhD,IAAoExB,SAAxE,EAAmF;AACxF,mBAAO,IAAP;AACD;AACF;AACF;;AAED,UAAID,MAAM,CAACQ,IAAP,KAAgB/C,iBAAiB,CAACiF,UAAtC,EAAkD;AAChD,YAAM7F,GAAG,GAAGmD,MAAM,CAACnD,GAAnB;AACA,YAAM8F,SAAS,GAAGnB,KAAK,CAACb,MAAN,CAAa0B,IAAb,CAAkB,UAAAhB,KAAK;AAAA,iBAAIA,KAAK,CAACxE,GAAN,KAAcA,GAAlB;AAAA,SAAvB,CAAlB;;AAEA,YAAI8F,SAAJ,EAAe;AACb,cAAMvD,QAAM,GAAG9C,aAAa,CAAC,EAAD,EAAKqG,SAAS,CAACvD,MAAf,EAAuB,EAAvB,EAA2BY,MAAM,CAACZ,MAAlC,CAA5B;;AAEA,cAAMuB,QAAM,sBAAOa,KAAK,CAACb,MAAb,CAAZ;;AACAA,UAAAA,QAAM,CAACa,KAAK,CAACb,MAAN,CAAalC,OAAb,CAAqBkE,SAArB,CAAD,CAAN,GAA0CrG,aAAa,CAAC,EAAD,EAAKqG,SAAL,EAAgB;AACrEvD,YAAAA,MAAM,EAANA;AADqE,WAAhB,CAAvD;AAGA,iBAAOW,YAAY,CAACC,MAAD,EAASC,SAAT,EAAoB3D,aAAa,CAAC,EAAD,EAAKkF,KAAL,EAAY;AAC9Db,YAAAA,MAAM,EAANA;AAD8D,WAAZ,CAAjC,CAAnB;AAGD;AACF;;AAED,UAAIc,gBAAgB,KAAKD,KAAK,CAACnB,KAA/B,EAAsC;AACpC,eAAON,YAAY,CAACC,MAAD,EAASC,SAAT,EAAoB3D,aAAa,CAAC,EAAD,EAAKkF,KAAL,EAAY;AAC9DnB,UAAAA,KAAK,EAAEoB;AADuD,SAAZ,CAAjC,CAAnB;AAGD,OAJD,MAIO,IAAIW,WAAW,IAAI,CAACb,UAApB,EAAgC;AACrC,eAAOC,KAAP;AACD,OAFM,MAEA,IAAIY,WAAJ,EAAiB;AACtB,eAAO9F,aAAa,CAAC,EAAD,EAAKkF,KAAL,CAApB;AACD;;AAED,UAAMoB,iBAAiB,GAAG5C,MAAM,CAACQ,IAAP,KAAgB/C,iBAAiB,CAACoD,IAAlC,IAA0Cb,MAAM,CAACQ,IAAP,KAAgB7C,YAAY,CAACkF,GAAvE,IAA8E7C,MAAM,CAACQ,IAAP,KAAgB7C,YAAY,CAACmF,UAArI;AACA,UAAMC,4BAA4B,GAAG,CAACH,iBAAD,IAAsB5C,MAAM,CAACQ,IAAP,KAAgB/C,iBAAiB,CAACoD,IAAlC,IAA0Cb,MAAM,CAACnD,GAAP,IAAc,IAAnH;;AAIA,UAAIkG,4BAAJ,EAAkC;AAChC,YAAI1C,MAAK,GAAGmB,KAAK,CAACnB,KAAlB;AACA,YAAIM,QAAM,GAAGa,KAAK,CAACb,MAAnB;AACA1C,QAAAA,KAAK,CAACoE,IAAN,CAAW,UAACC,OAAD,EAAU9F,CAAV,EAAgB;AACzB,cAAMmD,WAAW,GAAGZ,YAAY,CAACuD,OAAD,CAAhC;;AAEA,cAAI9F,CAAC,KAAK6D,MAAV,EAAiB;AACf,mBAAO,KAAP;AACD;;AAED,cAAIkC,UAAU,GAAG5B,QAAM,CAACnE,CAAD,CAAvB;;AAEA,cAAImD,WAAJ,EAAiB;AACf4C,YAAAA,UAAU,GAAG5C,WAAW,CAACG,iBAAZ,CAA8BE,MAA9B,EAAsCuC,UAAtC,CAAb;AACD;;AAED,cAAI,CAACA,UAAL,EAAiB;AACflC,YAAAA,MAAK,GAAG7D,CAAR;AACA,mBAAO,IAAP;AACD;;AAED,cAAI+F,UAAU,KAAK5B,QAAM,CAACnE,CAAD,CAAzB,EAA8B;AAC5BmE,YAAAA,QAAM,sBAAOA,QAAP,CAAN;AACAA,YAAAA,QAAM,CAACnE,CAAD,CAAN,GAAY+F,UAAZ;AACAlC,YAAAA,MAAK,GAAG7D,CAAR;AACA,mBAAO,IAAP;AACD;;AAED,iBAAO,KAAP;AACD,SA1BD;;AA6BA,YAAIwD,MAAM,CAACgD,aAAX,EAA0B;AACxB3C,UAAAA,MAAK,GAAGmB,KAAK,CAACnB,KAAd;AACD;;AAED,YAAIA,MAAK,KAAKmB,KAAK,CAACnB,KAAhB,IAAyBM,QAAM,KAAKa,KAAK,CAACb,MAA9C,EAAsD;AACpD,iBAAOZ,YAAY,CAACC,MAAD,EAASC,SAAT,EAAoB3D,aAAa,CAAC,EAAD,EAAKkF,KAAL,EAAY;AAC9DnB,YAAAA,KAAK,EAALA,MAD8D;AAE9DM,YAAAA,MAAM,EAANA;AAF8D,WAAZ,CAAjC,CAAnB;AAID;AACF;;AAED,aAAOa,KAAP;AACD,KA/MI;AAiNLyB,IAAAA,oBAjNK,gCAiNgBzB,KAjNhB,EAiNuB;AAC1B,UAAMxC,SAAS,GAAGwC,KAAK,CAACb,MAAN,CAAaa,KAAK,CAACnB,KAAnB,EAA0BrB,SAA5C;AACA1B,MAAAA,SAAS,CAAC0B,SAAD,EAAY,uCAAuCL,MAAvC,CAA8C6C,KAAK,CAACnB,KAApD,EAA2D,4FAA3D,CAAZ,CAAT;AACA,UAAMV,WAAW,GAAGZ,YAAY,CAACC,SAAD,CAAhC;;AAEA,UAAIW,WAAJ,EAAiB;AACf,eAAOA,WAAW,CAACsD,oBAAZ,CAAiCzB,KAAK,CAACb,MAAN,CAAaa,KAAK,CAACnB,KAAnB,CAAjC,CAAP;AACD;;AAED,aAAO9C,qBAAqB,CAACQ,YAAD,EAAeiB,SAAf,CAA5B;AACD,KA3NI;AA6NLkE,IAAAA,wBA7NK,oCA6NoBlE,SA7NpB,EA6N+B;AAClC,aAAOzB,qBAAqB,CAACQ,YAAD,EAAeiB,SAAf,CAA5B;AACD,KA/NI;AAiOLmE,IAAAA,wBAjOK,oCAiOoB3B,KAjOpB,EAiO2B;AAC9B,UAAMH,KAAK,GAAGG,KAAK,CAACb,MAAN,CAAaa,KAAK,CAACnB,KAAnB,CAAd;AACA,aAAOf,wBAAwB,CAAC+B,KAAD,CAA/B;AACD,KApOI;AAsOL9B,IAAAA,yBAtOK,qCAsOqB6D,IAtOrB,EAsO2BhE,MAtO3B,EAsOmC;AACtC,aAAOG,0BAAyB,CAAC6D,IAAD,EAAOhE,MAAP,CAAhC;AACD,KAxOI;AA0OLiE,IAAAA,gBAAgB,EAAE7F,kBAAkB,CAACO,YAAD,EAAeC,MAAM,CAACsF,wBAAtB;AA1O/B,GAAP;AA4OD,CAnWD","sourcesContent":["function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport invariant from '../utils/invariant';\nimport getScreenForRouteName from './getScreenForRouteName';\nimport createConfigGetter from './createConfigGetter';\nimport * as NavigationActions from '../NavigationActions';\nimport * as SwitchActions from './SwitchActions';\nimport * as StackActions from './StackActions';\nimport validateRouteConfigMap from './validateRouteConfigMap';\nimport { createPathParser } from './pathUtils';\n\nconst defaultActionCreators = () => ({});\n\nexport default ((routeConfigs, config = {}) => {\n  // Fail fast on invalid route definitions\n  validateRouteConfigMap(routeConfigs);\n  const order = config.order || Object.keys(routeConfigs);\n  const getCustomActionCreators = config.getCustomActionCreators || defaultActionCreators;\n  const initialRouteParams = config.initialRouteParams;\n  const initialRouteName = config.initialRouteName || order[0];\n  const backBehavior = config.backBehavior || 'none';\n  const resetOnBlur = config.hasOwnProperty('resetOnBlur') ? config.resetOnBlur : true;\n  const initialRouteIndex = order.indexOf(initialRouteName);\n\n  if (initialRouteIndex === -1) {\n    throw new Error(\"Invalid initialRouteName '\".concat(initialRouteName, \"'.\") + \"Should be one of \".concat(order.map(n => \"\\\"\".concat(n, \"\\\"\")).join(', ')));\n  }\n\n  const childRouters = {};\n  order.forEach(routeName => {\n    childRouters[routeName] = null;\n    const screen = getScreenForRouteName(routeConfigs, routeName);\n\n    if (screen.router) {\n      childRouters[routeName] = screen.router;\n    }\n  });\n\n  function getParamsForRoute(routeName, params) {\n    let routeConfig = routeConfigs[routeName];\n\n    if (routeConfig && routeConfig.params) {\n      return _objectSpread({}, routeConfig.params, {}, params);\n    } else {\n      return params;\n    }\n  }\n\n  const {\n    getPathAndParamsForRoute,\n    getActionForPathAndParams\n  } = createPathParser(childRouters, routeConfigs, config);\n\n  function resetChildRoute(routeName) {\n    let initialParams = routeName === initialRouteName ? initialRouteParams : undefined; // note(brentvatne): merging initialRouteParams *on top* of default params\n    // on the route seems incorrect but it's consistent with existing behavior\n    // in stackrouter\n\n    let params = getParamsForRoute(routeName, initialParams);\n    const childRouter = childRouters[routeName];\n\n    if (childRouter) {\n      const childAction = NavigationActions.init();\n      return _objectSpread({}, childRouter.getStateForAction(childAction), {\n        key: routeName,\n        routeName,\n        params\n      });\n    }\n\n    return {\n      key: routeName,\n      routeName,\n      params\n    };\n  }\n\n  function getNextState(action, prevState, possibleNextState) {\n    function updateNextStateHistory(prevState, nextState) {\n      if (backBehavior !== 'history' || prevState && nextState && nextState.index === prevState.index) {\n        return nextState;\n      }\n\n      let nextRouteKeyHistory = prevState ? prevState.routeKeyHistory : [];\n\n      if (action.type === NavigationActions.NAVIGATE) {\n        nextRouteKeyHistory = [...nextRouteKeyHistory]; // copy\n\n        const keyToAdd = nextState.routes[nextState.index].key;\n        nextRouteKeyHistory = nextRouteKeyHistory.filter(k => k !== keyToAdd); // dedup\n\n        nextRouteKeyHistory.push(keyToAdd);\n      } else if (action.type === NavigationActions.BACK) {\n        nextRouteKeyHistory = [...nextRouteKeyHistory]; // copy\n\n        nextRouteKeyHistory.pop();\n      }\n\n      return _objectSpread({}, nextState, {\n        routeKeyHistory: nextRouteKeyHistory\n      });\n    }\n\n    let nextState = possibleNextState;\n\n    if (prevState && possibleNextState && prevState.index !== possibleNextState.index && resetOnBlur) {\n      const prevRouteName = prevState.routes[prevState.index].routeName;\n      const nextRoutes = [...possibleNextState.routes];\n      nextRoutes[prevState.index] = resetChildRoute(prevRouteName);\n      nextState = _objectSpread({}, possibleNextState, {\n        routes: nextRoutes\n      });\n    }\n\n    return updateNextStateHistory(prevState, nextState);\n  }\n\n  function getInitialState() {\n    const routes = order.map(resetChildRoute);\n    const initialState = {\n      routes,\n      index: initialRouteIndex\n    };\n\n    if (backBehavior === 'history') {\n      const initialKey = routes[initialRouteIndex].key;\n      initialState['routeKeyHistory'] = [initialKey];\n    }\n\n    return initialState;\n  }\n\n  return {\n    childRouters,\n\n    getActionCreators(route, stateKey) {\n      return getCustomActionCreators(route, stateKey);\n    },\n\n    getStateForAction(action, inputState) {\n      let prevState = inputState ? _objectSpread({}, inputState) : inputState;\n      let state = inputState || getInitialState();\n      let activeChildIndex = state.index;\n\n      if (action.type === NavigationActions.INIT) {\n        // NOTE(brentvatne): this seems weird... why are we merging these\n        // params into child routes?\n        // ---------------------------------------------------------------\n        // Merge any params from the action into all the child routes\n        const {\n          params\n        } = action;\n\n        if (params) {\n          state.routes = state.routes.map(route => _objectSpread({}, route, {\n            params: _objectSpread({}, route.params, {}, params, {}, route.routeName === initialRouteName ? initialRouteParams : null)\n          }));\n        }\n      }\n\n      if (action.type === SwitchActions.JUMP_TO && (action.key == null || action.key === state.key)) {\n        const {\n          params\n        } = action;\n        const index = state.routes.findIndex(route => route.routeName === action.routeName);\n\n        if (index === -1) {\n          throw new Error(\"There is no route named '\".concat(action.routeName, \"' in the navigator with the key '\").concat(action.key, \"'.\\n\") + \"Must be one of: \".concat(state.routes.map(route => \"'\".concat(route.routeName, \"'\")).join(',')));\n        }\n\n        return getNextState(action, prevState, _objectSpread({}, state, {\n          routes: params ? state.routes.map((route, i) => i === index ? _objectSpread({}, route, {\n            params: _objectSpread({}, route.params, {}, params)\n          }) : route) : state.routes,\n          index\n        }));\n      } // Let the current child handle it\n\n\n      const activeChildLastState = state.routes[state.index];\n      const activeChildRouter = childRouters[order[state.index]];\n\n      if (activeChildRouter) {\n        const activeChildState = activeChildRouter.getStateForAction(action, activeChildLastState);\n\n        if (!activeChildState && inputState) {\n          return null;\n        }\n\n        if (activeChildState && activeChildState !== activeChildLastState) {\n          const routes = [...state.routes];\n          routes[state.index] = activeChildState;\n          return getNextState(action, prevState, _objectSpread({}, state, {\n            routes\n          }));\n        }\n      } // Handle tab changing. Do this after letting the current tab try to\n      // handle the action, to allow inner children to change first\n\n\n      const isBackEligible = action.key == null || action.key === activeChildLastState.key;\n\n      if (action.type === NavigationActions.BACK) {\n        if (isBackEligible && backBehavior === 'initialRoute') {\n          activeChildIndex = initialRouteIndex;\n        } else if (isBackEligible && backBehavior === 'order') {\n          activeChildIndex = Math.max(0, activeChildIndex - 1);\n        } // The history contains current route, so we can only go back\n        // if there is more than one item in the history\n        else if (isBackEligible && backBehavior === 'history' && state.routeKeyHistory.length > 1) {\n            const routeKey = state.routeKeyHistory[state.routeKeyHistory.length - 2];\n            activeChildIndex = order.indexOf(routeKey);\n          }\n      }\n\n      let didNavigate = false;\n\n      if (action.type === NavigationActions.NAVIGATE) {\n        didNavigate = !!order.find((childId, i) => {\n          if (childId === action.routeName) {\n            activeChildIndex = i;\n            return true;\n          }\n\n          return false;\n        });\n\n        if (didNavigate) {\n          const childState = state.routes[activeChildIndex];\n          const childRouter = childRouters[action.routeName];\n          let newChildState = childState;\n\n          if (action.action && childRouter) {\n            const childStateUpdate = childRouter.getStateForAction(action.action, childState);\n\n            if (childStateUpdate) {\n              newChildState = childStateUpdate;\n            }\n          }\n\n          if (action.params) {\n            newChildState = _objectSpread({}, newChildState, {\n              params: _objectSpread({}, newChildState.params || {}, {}, action.params)\n            });\n          }\n\n          if (newChildState !== childState) {\n            const routes = [...state.routes];\n            routes[activeChildIndex] = newChildState;\n\n            const nextState = _objectSpread({}, state, {\n              routes,\n              index: activeChildIndex\n            });\n\n            return getNextState(action, prevState, nextState);\n          } else if (newChildState === childState && state.index === activeChildIndex && prevState) {\n            return null;\n          }\n        }\n      }\n\n      if (action.type === NavigationActions.SET_PARAMS) {\n        const key = action.key;\n        const lastRoute = state.routes.find(route => route.key === key);\n\n        if (lastRoute) {\n          const params = _objectSpread({}, lastRoute.params, {}, action.params);\n\n          const routes = [...state.routes];\n          routes[state.routes.indexOf(lastRoute)] = _objectSpread({}, lastRoute, {\n            params\n          });\n          return getNextState(action, prevState, _objectSpread({}, state, {\n            routes\n          }));\n        }\n      }\n\n      if (activeChildIndex !== state.index) {\n        return getNextState(action, prevState, _objectSpread({}, state, {\n          index: activeChildIndex\n        }));\n      } else if (didNavigate && !inputState) {\n        return state;\n      } else if (didNavigate) {\n        return _objectSpread({}, state);\n      }\n\n      const isActionBackOrPop = action.type === NavigationActions.BACK || action.type === StackActions.POP || action.type === StackActions.POP_TO_TOP;\n      const sendActionToInactiveChildren = !isActionBackOrPop || action.type === NavigationActions.BACK && action.key != null; // Let other children handle it and switch to the first child that returns a new state\n      // Do not do this for StackActions.POP or NavigationActions.BACK actions without a key:\n      // it would be unintuitive for these actions to switch to another tab just because that tab had a Stack that could accept a back action\n\n      if (sendActionToInactiveChildren) {\n        let index = state.index;\n        let routes = state.routes;\n        order.find((childId, i) => {\n          const childRouter = childRouters[childId];\n\n          if (i === index) {\n            return false;\n          }\n\n          let childState = routes[i];\n\n          if (childRouter) {\n            childState = childRouter.getStateForAction(action, childState);\n          }\n\n          if (!childState) {\n            index = i;\n            return true;\n          }\n\n          if (childState !== routes[i]) {\n            routes = [...routes];\n            routes[i] = childState;\n            index = i;\n            return true;\n          }\n\n          return false;\n        }); // Nested routers can be updated after switching children with actions such as SET_PARAMS\n        // and COMPLETE_TRANSITION.\n\n        if (action.preserveFocus) {\n          index = state.index;\n        }\n\n        if (index !== state.index || routes !== state.routes) {\n          return getNextState(action, prevState, _objectSpread({}, state, {\n            index,\n            routes\n          }));\n        }\n      }\n\n      return state;\n    },\n\n    getComponentForState(state) {\n      const routeName = state.routes[state.index].routeName;\n      invariant(routeName, \"There is no route defined for index \".concat(state.index, \". Check that\\n        that you passed in a navigation state with a valid tab/screen index.\"));\n      const childRouter = childRouters[routeName];\n\n      if (childRouter) {\n        return childRouter.getComponentForState(state.routes[state.index]);\n      }\n\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n\n    getComponentForRouteName(routeName) {\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n\n    getPathAndParamsForState(state) {\n      const route = state.routes[state.index];\n      return getPathAndParamsForRoute(route);\n    },\n\n    getActionForPathAndParams(path, params) {\n      return getActionForPathAndParams(path, params);\n    },\n\n    getScreenOptions: createConfigGetter(routeConfigs, config.defaultNavigationOptions)\n  };\n});\n//# sourceMappingURL=SwitchRouter.js.map"]},"metadata":{},"sourceType":"module"}