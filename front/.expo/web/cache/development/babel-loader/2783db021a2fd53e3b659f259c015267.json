{"ast":null,"code":"import { LABEL_PADDING_HORIZONTAL, ADORNMENT_OFFSET, ADORNMENT_SIZE, FLAT_INPUT_OFFSET } from \"./constants\";\nimport { AdornmentType, AdornmentSide } from \"./Adornment/enums\";\nexport var calculateLabelTopPosition = function calculateLabelTopPosition(labelHeight) {\n  var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var optionalPadding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var customHeight = height > 0 ? height : 0;\n  return Math.floor((customHeight - labelHeight) / 2 + optionalPadding);\n};\nexport var calculateInputHeight = function calculateInputHeight(labelHeight) {\n  var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var minHeight = arguments.length > 2 ? arguments[2] : undefined;\n  var finalHeight = height > 0 ? height : labelHeight;\n  if (height > 0) return height;\n  return finalHeight < minHeight ? minHeight : finalHeight;\n};\nexport var calculatePadding = function calculatePadding(props) {\n  var height = props.height,\n      _props$multiline = props.multiline,\n      multiline = _props$multiline === void 0 ? false : _props$multiline;\n  var result = 0;\n\n  if (multiline) {\n    if (height && multiline) {\n      result = calculateTextAreaPadding(props);\n    } else {\n      result = calculateInputPadding(props);\n    }\n  }\n\n  return Math.max(0, result);\n};\n\nvar calculateTextAreaPadding = function calculateTextAreaPadding(props) {\n  var dense = props.dense;\n  return dense ? 10 : 20;\n};\n\nvar calculateInputPadding = function calculateInputPadding(_ref) {\n  var topPosition = _ref.topPosition,\n      fontSize = _ref.fontSize,\n      multiline = _ref.multiline,\n      scale = _ref.scale,\n      dense = _ref.dense,\n      offset = _ref.offset,\n      isAndroid = _ref.isAndroid;\n  var refFontSize = scale * fontSize;\n  var result = Math.floor(topPosition / 2);\n  result = result + Math.floor((refFontSize - fontSize) / 2) - (scale < 1 ? offset / 2 : 0);\n  if (multiline && isAndroid) result = Math.min(dense ? offset / 2 : offset, result);\n  return result;\n};\n\nexport var adjustPaddingOut = function adjustPaddingOut(_ref2) {\n  var pad = _ref2.pad,\n      multiline = _ref2.multiline,\n      label = _ref2.label,\n      scale = _ref2.scale,\n      height = _ref2.height,\n      fontSize = _ref2.fontSize,\n      lineHeight = _ref2.lineHeight,\n      dense = _ref2.dense,\n      offset = _ref2.offset,\n      isAndroid = _ref2.isAndroid;\n  var fontHeight = lineHeight !== null && lineHeight !== void 0 ? lineHeight : fontSize;\n  var refFontHeight = scale * fontSize;\n  var result = pad;\n\n  if (height && !multiline) {\n    return {\n      paddingTop: Math.max(0, (height - fontHeight) / 2),\n      paddingBottom: Math.max(0, (height - fontHeight) / 2)\n    };\n  }\n\n  if (!isAndroid && multiline) {\n    if (dense) {\n      if (label) {\n        result += scale < 1 ? Math.min(offset, refFontHeight / 2 * scale) : 0;\n      } else {\n        result += 0;\n      }\n    }\n\n    if (!dense) {\n      if (label) {\n        result += scale < 1 ? Math.min(offset, refFontHeight * scale) : Math.min(offset / 2, refFontHeight * scale);\n      } else {\n        result += scale < 1 ? Math.min(offset / 2, refFontHeight * scale) : 0;\n      }\n    }\n\n    result = Math.floor(result);\n  }\n\n  return {\n    paddingTop: result,\n    paddingBottom: result\n  };\n};\nexport var adjustPaddingFlat = function adjustPaddingFlat(_ref3) {\n  var pad = _ref3.pad,\n      scale = _ref3.scale,\n      multiline = _ref3.multiline,\n      label = _ref3.label,\n      height = _ref3.height,\n      offset = _ref3.offset,\n      dense = _ref3.dense,\n      fontSize = _ref3.fontSize,\n      isAndroid = _ref3.isAndroid,\n      styles = _ref3.styles;\n  var result = pad;\n  var topResult = result;\n  var bottomResult = result;\n  var paddingTop = styles.paddingTop,\n      paddingBottom = styles.paddingBottom;\n  var refFontSize = scale * fontSize;\n\n  if (!multiline) {\n    if (label) {\n      return {\n        paddingTop: paddingTop,\n        paddingBottom: paddingBottom\n      };\n    }\n\n    return {\n      paddingTop: result,\n      paddingBottom: result\n    };\n  }\n\n  if (label) {\n    topResult = paddingTop;\n    bottomResult = paddingBottom;\n\n    if (!isAndroid) {\n      if (dense) {\n        topResult += scale < 1 ? Math.min(result, refFontSize * scale) - result / 2 : Math.min(result, refFontSize * scale) - result / 2;\n      }\n\n      if (!dense) {\n        topResult += scale < 1 ? Math.min(offset / 2, refFontSize * scale) : Math.min(result, refFontSize * scale) - offset / 2;\n      }\n    }\n\n    topResult = Math.floor(topResult);\n  } else {\n    if (height) {\n      return {\n        paddingTop: Math.max(0, (height - fontSize) / 2),\n        paddingBottom: Math.max(0, (height - fontSize) / 2)\n      };\n    }\n\n    if (!isAndroid) {\n      if (dense) {\n        result += scale < 1 ? Math.min(offset / 2, fontSize / 2 * scale) : Math.min(offset / 2, scale);\n      }\n\n      if (!dense) {\n        result += scale < 1 ? Math.min(offset, fontSize * scale) : Math.min(fontSize, offset / 2 * scale);\n      }\n\n      result = Math.floor(result);\n      topResult = result;\n      bottomResult = result;\n    }\n  }\n\n  return {\n    paddingTop: Math.max(0, topResult),\n    paddingBottom: Math.max(0, bottomResult)\n  };\n};\nexport var interpolatePlaceholder = function interpolatePlaceholder(labeled, hasActiveOutline) {\n  return labeled.interpolate({\n    inputRange: [0, 1],\n    outputRange: [hasActiveOutline ? 0 : 1, 1]\n  });\n};\nexport function calculateFlatAffixTopPosition(_ref4) {\n  var height = _ref4.height,\n      paddingTop = _ref4.paddingTop,\n      paddingBottom = _ref4.paddingBottom,\n      affixHeight = _ref4.affixHeight;\n  var inputHeightWithoutPadding = height - paddingTop - paddingBottom;\n  var halfOfTheInputHeightDecreasedByAffixHeight = (inputHeightWithoutPadding - affixHeight) / 2;\n  return paddingTop + halfOfTheInputHeightDecreasedByAffixHeight;\n}\nexport function calculateOutlinedIconAndAffixTopPosition(_ref5) {\n  var height = _ref5.height,\n      affixHeight = _ref5.affixHeight,\n      labelYOffset = _ref5.labelYOffset;\n  return (height - affixHeight + labelYOffset) / 2;\n}\nexport var calculateFlatInputHorizontalPadding = function calculateFlatInputHorizontalPadding(_ref6) {\n  var adornmentConfig = _ref6.adornmentConfig;\n  var paddingLeft = LABEL_PADDING_HORIZONTAL;\n  var paddingRight = LABEL_PADDING_HORIZONTAL;\n  adornmentConfig.forEach(function (_ref7) {\n    var type = _ref7.type,\n        side = _ref7.side;\n\n    if (type === AdornmentType.Icon && side === AdornmentSide.Left) {\n      paddingLeft = ADORNMENT_SIZE + ADORNMENT_OFFSET + FLAT_INPUT_OFFSET;\n    } else if (side === AdornmentSide.Right) {\n      if (type === AdornmentType.Affix) {\n        paddingRight = ADORNMENT_SIZE + ADORNMENT_OFFSET + FLAT_INPUT_OFFSET;\n      } else if (type === AdornmentType.Icon) {\n        paddingRight = ADORNMENT_SIZE + ADORNMENT_OFFSET + FLAT_INPUT_OFFSET;\n      }\n    }\n  });\n  return {\n    paddingLeft: paddingLeft,\n    paddingRight: paddingRight\n  };\n};\nexport function areLabelsEqual(label1, label2) {\n  if (label1 === label2) {\n    return true;\n  }\n\n  if (!(label1 || label2)) {\n    return true;\n  }\n\n  if (!(label1 && label2)) {\n    return false;\n  }\n\n  if (typeof label1 !== typeof label2) {\n    return false;\n  }\n\n  if (typeof label1 === 'string' || label1 instanceof String || typeof label2 === 'string' || label2 instanceof String) {\n    return false;\n  }\n\n  if (label1.type !== label2.type) {\n    return false;\n  }\n\n  var label1Props = label1.props || {};\n  var label2Props = label2.props || {};\n\n  if (JSON.stringify(label1Props) !== JSON.stringify(label2Props)) {\n    return false;\n  }\n\n  if (!(label1Props.children || label2Props.children)) {\n    return true;\n  }\n\n  if (!(label1Props.children && label2Props.children)) {\n    return false;\n  }\n\n  var label1IsArray = Array.isArray(label1Props.children);\n  var label2IsArray = Array.isArray(label2Props.children);\n\n  if (label1IsArray && label2IsArray) {\n    var children1 = label1Props.children;\n    var children2 = label2Props.children;\n\n    if (children1.length !== children2.length) {\n      return false;\n    }\n\n    for (var i = 0; i < children1.length; i++) {\n      if (!areLabelsEqual(children1[i], children2[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  if (label1IsArray || label2IsArray) {\n    return false;\n  }\n\n  return areLabelsEqual(label1Props.children, label2Props.children);\n}","map":{"version":3,"sources":["C:/LearnEZ/node_modules/react-native-paper/lib/module/components/TextInput/helpers.js"],"names":["LABEL_PADDING_HORIZONTAL","ADORNMENT_OFFSET","ADORNMENT_SIZE","FLAT_INPUT_OFFSET","AdornmentType","AdornmentSide","calculateLabelTopPosition","labelHeight","height","optionalPadding","customHeight","Math","floor","calculateInputHeight","minHeight","finalHeight","calculatePadding","props","multiline","result","calculateTextAreaPadding","calculateInputPadding","max","dense","topPosition","fontSize","scale","offset","isAndroid","refFontSize","min","adjustPaddingOut","pad","label","lineHeight","fontHeight","refFontHeight","paddingTop","paddingBottom","adjustPaddingFlat","styles","topResult","bottomResult","interpolatePlaceholder","labeled","hasActiveOutline","interpolate","inputRange","outputRange","calculateFlatAffixTopPosition","affixHeight","inputHeightWithoutPadding","halfOfTheInputHeightDecreasedByAffixHeight","calculateOutlinedIconAndAffixTopPosition","labelYOffset","calculateFlatInputHorizontalPadding","adornmentConfig","paddingLeft","paddingRight","forEach","type","side","Icon","Left","Right","Affix","areLabelsEqual","label1","label2","String","label1Props","label2Props","JSON","stringify","children","label1IsArray","Array","isArray","label2IsArray","children1","children2","length","i"],"mappings":"AAAA,SAASA,wBAAT,EAAmCC,gBAAnC,EAAqDC,cAArD,EAAqEC,iBAArE;AACA,SAASC,aAAT,EAAwBC,aAAxB;AACA,OAAO,IAAMC,yBAAyB,GAAG,SAA5BA,yBAA4B,CAACC,WAAD,EAAkD;AAAA,MAApCC,MAAoC,uEAA3B,CAA2B;AAAA,MAAxBC,eAAwB,uEAAN,CAAM;AACzF,MAAMC,YAAY,GAAGF,MAAM,GAAG,CAAT,GAAaA,MAAb,GAAsB,CAA3C;AACA,SAAOG,IAAI,CAACC,KAAL,CAAW,CAACF,YAAY,GAAGH,WAAhB,IAA+B,CAA/B,GAAmCE,eAA9C,CAAP;AACD,CAHM;AAIP,OAAO,IAAMI,oBAAoB,GAAG,SAAvBA,oBAAuB,CAACN,WAAD,EAAwC;AAAA,MAA1BC,MAA0B,uEAAjB,CAAiB;AAAA,MAAdM,SAAc;AAC1E,MAAMC,WAAW,GAAGP,MAAM,GAAG,CAAT,GAAaA,MAAb,GAAsBD,WAA1C;AACA,MAAIC,MAAM,GAAG,CAAb,EAAgB,OAAOA,MAAP;AAChB,SAAOO,WAAW,GAAGD,SAAd,GAA0BA,SAA1B,GAAsCC,WAA7C;AACD,CAJM;AAKP,OAAO,IAAMC,gBAAgB,GAAG,SAAnBA,gBAAmB,CAAAC,KAAK,EAAI;AACvC,MACET,MADF,GAGIS,KAHJ,CACET,MADF;AAAA,yBAGIS,KAHJ,CAEEC,SAFF;AAAA,MAEEA,SAFF,iCAEc,KAFd;AAIA,MAAIC,MAAM,GAAG,CAAb;;AAEA,MAAID,SAAJ,EAAe;AACb,QAAIV,MAAM,IAAIU,SAAd,EAAyB;AACvBC,MAAAA,MAAM,GAAGC,wBAAwB,CAACH,KAAD,CAAjC;AACD,KAFD,MAEO;AACLE,MAAAA,MAAM,GAAGE,qBAAqB,CAACJ,KAAD,CAA9B;AACD;AACF;;AAED,SAAON,IAAI,CAACW,GAAL,CAAS,CAAT,EAAYH,MAAZ,CAAP;AACD,CAhBM;;AAkBP,IAAMC,wBAAwB,GAAG,SAA3BA,wBAA2B,CAAAH,KAAK,EAAI;AACxC,MACEM,KADF,GAEIN,KAFJ,CACEM,KADF;AAGA,SAAOA,KAAK,GAAG,EAAH,GAAQ,EAApB;AACD,CALD;;AAOA,IAAMF,qBAAqB,GAAG,SAAxBA,qBAAwB,OAQxB;AAAA,MAPJG,WAOI,QAPJA,WAOI;AAAA,MANJC,QAMI,QANJA,QAMI;AAAA,MALJP,SAKI,QALJA,SAKI;AAAA,MAJJQ,KAII,QAJJA,KAII;AAAA,MAHJH,KAGI,QAHJA,KAGI;AAAA,MAFJI,MAEI,QAFJA,MAEI;AAAA,MADJC,SACI,QADJA,SACI;AACJ,MAAMC,WAAW,GAAGH,KAAK,GAAGD,QAA5B;AACA,MAAIN,MAAM,GAAGR,IAAI,CAACC,KAAL,CAAWY,WAAW,GAAG,CAAzB,CAAb;AACAL,EAAAA,MAAM,GAAGA,MAAM,GAAGR,IAAI,CAACC,KAAL,CAAW,CAACiB,WAAW,GAAGJ,QAAf,IAA2B,CAAtC,CAAT,IAAqDC,KAAK,GAAG,CAAR,GAAYC,MAAM,GAAG,CAArB,GAAyB,CAA9E,CAAT;AACA,MAAIT,SAAS,IAAIU,SAAjB,EAA4BT,MAAM,GAAGR,IAAI,CAACmB,GAAL,CAASP,KAAK,GAAGI,MAAM,GAAG,CAAZ,GAAgBA,MAA9B,EAAsCR,MAAtC,CAAT;AAC5B,SAAOA,MAAP;AACD,CAdD;;AAgBA,OAAO,IAAMY,gBAAgB,GAAG,SAAnBA,gBAAmB,QAW1B;AAAA,MAVJC,GAUI,SAVJA,GAUI;AAAA,MATJd,SASI,SATJA,SASI;AAAA,MARJe,KAQI,SARJA,KAQI;AAAA,MAPJP,KAOI,SAPJA,KAOI;AAAA,MANJlB,MAMI,SANJA,MAMI;AAAA,MALJiB,QAKI,SALJA,QAKI;AAAA,MAJJS,UAII,SAJJA,UAII;AAAA,MAHJX,KAGI,SAHJA,KAGI;AAAA,MAFJI,MAEI,SAFJA,MAEI;AAAA,MADJC,SACI,SADJA,SACI;AACJ,MAAMO,UAAU,GAAGD,UAAU,KAAK,IAAf,IAAuBA,UAAU,KAAK,KAAK,CAA3C,GAA+CA,UAA/C,GAA4DT,QAA/E;AACA,MAAMW,aAAa,GAAGV,KAAK,GAAGD,QAA9B;AACA,MAAIN,MAAM,GAAGa,GAAb;;AAEA,MAAIxB,MAAM,IAAI,CAACU,SAAf,EAA0B;AACxB,WAAO;AACLmB,MAAAA,UAAU,EAAE1B,IAAI,CAACW,GAAL,CAAS,CAAT,EAAY,CAACd,MAAM,GAAG2B,UAAV,IAAwB,CAApC,CADP;AAELG,MAAAA,aAAa,EAAE3B,IAAI,CAACW,GAAL,CAAS,CAAT,EAAY,CAACd,MAAM,GAAG2B,UAAV,IAAwB,CAApC;AAFV,KAAP;AAID;;AAED,MAAI,CAACP,SAAD,IAAcV,SAAlB,EAA6B;AAC3B,QAAIK,KAAJ,EAAW;AACT,UAAIU,KAAJ,EAAW;AACTd,QAAAA,MAAM,IAAIO,KAAK,GAAG,CAAR,GAAYf,IAAI,CAACmB,GAAL,CAASH,MAAT,EAAiBS,aAAa,GAAG,CAAhB,GAAoBV,KAArC,CAAZ,GAA0D,CAApE;AACD,OAFD,MAEO;AACLP,QAAAA,MAAM,IAAI,CAAV;AACD;AACF;;AAED,QAAI,CAACI,KAAL,EAAY;AACV,UAAIU,KAAJ,EAAW;AACTd,QAAAA,MAAM,IAAIO,KAAK,GAAG,CAAR,GAAYf,IAAI,CAACmB,GAAL,CAASH,MAAT,EAAiBS,aAAa,GAAGV,KAAjC,CAAZ,GAAsDf,IAAI,CAACmB,GAAL,CAASH,MAAM,GAAG,CAAlB,EAAqBS,aAAa,GAAGV,KAArC,CAAhE;AACD,OAFD,MAEO;AACLP,QAAAA,MAAM,IAAIO,KAAK,GAAG,CAAR,GAAYf,IAAI,CAACmB,GAAL,CAASH,MAAM,GAAG,CAAlB,EAAqBS,aAAa,GAAGV,KAArC,CAAZ,GAA0D,CAApE;AACD;AACF;;AAEDP,IAAAA,MAAM,GAAGR,IAAI,CAACC,KAAL,CAAWO,MAAX,CAAT;AACD;;AAED,SAAO;AACLkB,IAAAA,UAAU,EAAElB,MADP;AAELmB,IAAAA,aAAa,EAAEnB;AAFV,GAAP;AAID,CA/CM;AAgDP,OAAO,IAAMoB,iBAAiB,GAAG,SAApBA,iBAAoB,QAW3B;AAAA,MAVJP,GAUI,SAVJA,GAUI;AAAA,MATJN,KASI,SATJA,KASI;AAAA,MARJR,SAQI,SARJA,SAQI;AAAA,MAPJe,KAOI,SAPJA,KAOI;AAAA,MANJzB,MAMI,SANJA,MAMI;AAAA,MALJmB,MAKI,SALJA,MAKI;AAAA,MAJJJ,KAII,SAJJA,KAII;AAAA,MAHJE,QAGI,SAHJA,QAGI;AAAA,MAFJG,SAEI,SAFJA,SAEI;AAAA,MADJY,MACI,SADJA,MACI;AACJ,MAAIrB,MAAM,GAAGa,GAAb;AACA,MAAIS,SAAS,GAAGtB,MAAhB;AACA,MAAIuB,YAAY,GAAGvB,MAAnB;AACA,MACEkB,UADF,GAGIG,MAHJ,CACEH,UADF;AAAA,MAEEC,aAFF,GAGIE,MAHJ,CAEEF,aAFF;AAIA,MAAMT,WAAW,GAAGH,KAAK,GAAGD,QAA5B;;AAEA,MAAI,CAACP,SAAL,EAAgB;AAEd,QAAIe,KAAJ,EAAW;AAET,aAAO;AACLI,QAAAA,UAAU,EAAVA,UADK;AAELC,QAAAA,aAAa,EAAbA;AAFK,OAAP;AAID;;AAGD,WAAO;AACLD,MAAAA,UAAU,EAAElB,MADP;AAELmB,MAAAA,aAAa,EAAEnB;AAFV,KAAP;AAID;;AAED,MAAIc,KAAJ,EAAW;AAETQ,IAAAA,SAAS,GAAGJ,UAAZ;AACAK,IAAAA,YAAY,GAAGJ,aAAf;;AAEA,QAAI,CAACV,SAAL,EAAgB;AACd,UAAIL,KAAJ,EAAW;AACTkB,QAAAA,SAAS,IAAIf,KAAK,GAAG,CAAR,GAAYf,IAAI,CAACmB,GAAL,CAASX,MAAT,EAAiBU,WAAW,GAAGH,KAA/B,IAAwCP,MAAM,GAAG,CAA7D,GAAiER,IAAI,CAACmB,GAAL,CAASX,MAAT,EAAiBU,WAAW,GAAGH,KAA/B,IAAwCP,MAAM,GAAG,CAA/H;AACD;;AAED,UAAI,CAACI,KAAL,EAAY;AACVkB,QAAAA,SAAS,IAAIf,KAAK,GAAG,CAAR,GAAYf,IAAI,CAACmB,GAAL,CAASH,MAAM,GAAG,CAAlB,EAAqBE,WAAW,GAAGH,KAAnC,CAAZ,GAAwDf,IAAI,CAACmB,GAAL,CAASX,MAAT,EAAiBU,WAAW,GAAGH,KAA/B,IAAwCC,MAAM,GAAG,CAAtH;AACD;AACF;;AAEDc,IAAAA,SAAS,GAAG9B,IAAI,CAACC,KAAL,CAAW6B,SAAX,CAAZ;AACD,GAhBD,MAgBO;AACL,QAAIjC,MAAJ,EAAY;AAEV,aAAO;AACL6B,QAAAA,UAAU,EAAE1B,IAAI,CAACW,GAAL,CAAS,CAAT,EAAY,CAACd,MAAM,GAAGiB,QAAV,IAAsB,CAAlC,CADP;AAELa,QAAAA,aAAa,EAAE3B,IAAI,CAACW,GAAL,CAAS,CAAT,EAAY,CAACd,MAAM,GAAGiB,QAAV,IAAsB,CAAlC;AAFV,OAAP;AAID;;AAGD,QAAI,CAACG,SAAL,EAAgB;AACd,UAAIL,KAAJ,EAAW;AACTJ,QAAAA,MAAM,IAAIO,KAAK,GAAG,CAAR,GAAYf,IAAI,CAACmB,GAAL,CAASH,MAAM,GAAG,CAAlB,EAAqBF,QAAQ,GAAG,CAAX,GAAeC,KAApC,CAAZ,GAAyDf,IAAI,CAACmB,GAAL,CAASH,MAAM,GAAG,CAAlB,EAAqBD,KAArB,CAAnE;AACD;;AAED,UAAI,CAACH,KAAL,EAAY;AACVJ,QAAAA,MAAM,IAAIO,KAAK,GAAG,CAAR,GAAYf,IAAI,CAACmB,GAAL,CAASH,MAAT,EAAiBF,QAAQ,GAAGC,KAA5B,CAAZ,GAAiDf,IAAI,CAACmB,GAAL,CAASL,QAAT,EAAmBE,MAAM,GAAG,CAAT,GAAaD,KAAhC,CAA3D;AACD;;AAEDP,MAAAA,MAAM,GAAGR,IAAI,CAACC,KAAL,CAAWO,MAAX,CAAT;AACAsB,MAAAA,SAAS,GAAGtB,MAAZ;AACAuB,MAAAA,YAAY,GAAGvB,MAAf;AACD;AACF;;AAED,SAAO;AACLkB,IAAAA,UAAU,EAAE1B,IAAI,CAACW,GAAL,CAAS,CAAT,EAAYmB,SAAZ,CADP;AAELH,IAAAA,aAAa,EAAE3B,IAAI,CAACW,GAAL,CAAS,CAAT,EAAYoB,YAAZ;AAFV,GAAP;AAID,CAnFM;AAoFP,OAAO,IAAMC,sBAAsB,GAAG,SAAzBA,sBAAyB,CAACC,OAAD,EAAUC,gBAAV;AAAA,SAA+BD,OAAO,CAACE,WAAR,CAAoB;AACvFC,IAAAA,UAAU,EAAE,CAAC,CAAD,EAAI,CAAJ,CAD2E;AAEvFC,IAAAA,WAAW,EAAE,CAACH,gBAAgB,GAAG,CAAH,GAAO,CAAxB,EAA2B,CAA3B;AAF0E,GAApB,CAA/B;AAAA,CAA/B;AAIP,OAAO,SAASI,6BAAT,QAKJ;AAAA,MAJDzC,MAIC,SAJDA,MAIC;AAAA,MAHD6B,UAGC,SAHDA,UAGC;AAAA,MAFDC,aAEC,SAFDA,aAEC;AAAA,MADDY,WACC,SADDA,WACC;AACD,MAAMC,yBAAyB,GAAG3C,MAAM,GAAG6B,UAAT,GAAsBC,aAAxD;AACA,MAAMc,0CAA0C,GAAG,CAACD,yBAAyB,GAAGD,WAA7B,IAA4C,CAA/F;AACA,SAAOb,UAAU,GAAGe,0CAApB;AACD;AACD,OAAO,SAASC,wCAAT,QAIJ;AAAA,MAHD7C,MAGC,SAHDA,MAGC;AAAA,MAFD0C,WAEC,SAFDA,WAEC;AAAA,MADDI,YACC,SADDA,YACC;AACD,SAAO,CAAC9C,MAAM,GAAG0C,WAAT,GAAuBI,YAAxB,IAAwC,CAA/C;AACD;AACD,OAAO,IAAMC,mCAAmC,GAAG,SAAtCA,mCAAsC,QAE7C;AAAA,MADJC,eACI,SADJA,eACI;AACJ,MAAIC,WAAW,GAAGzD,wBAAlB;AACA,MAAI0D,YAAY,GAAG1D,wBAAnB;AACAwD,EAAAA,eAAe,CAACG,OAAhB,CAAwB,iBAGlB;AAAA,QAFJC,IAEI,SAFJA,IAEI;AAAA,QADJC,IACI,SADJA,IACI;;AACJ,QAAID,IAAI,KAAKxD,aAAa,CAAC0D,IAAvB,IAA+BD,IAAI,KAAKxD,aAAa,CAAC0D,IAA1D,EAAgE;AAC9DN,MAAAA,WAAW,GAAGvD,cAAc,GAAGD,gBAAjB,GAAoCE,iBAAlD;AACD,KAFD,MAEO,IAAI0D,IAAI,KAAKxD,aAAa,CAAC2D,KAA3B,EAAkC;AACvC,UAAIJ,IAAI,KAAKxD,aAAa,CAAC6D,KAA3B,EAAkC;AAChCP,QAAAA,YAAY,GAAGxD,cAAc,GAAGD,gBAAjB,GAAoCE,iBAAnD;AACD,OAFD,MAEO,IAAIyD,IAAI,KAAKxD,aAAa,CAAC0D,IAA3B,EAAiC;AACtCJ,QAAAA,YAAY,GAAGxD,cAAc,GAAGD,gBAAjB,GAAoCE,iBAAnD;AACD;AACF;AACF,GAbD;AAcA,SAAO;AACLsD,IAAAA,WAAW,EAAXA,WADK;AAELC,IAAAA,YAAY,EAAZA;AAFK,GAAP;AAID,CAvBM;AAwBP,OAAO,SAASQ,cAAT,CAAwBC,MAAxB,EAAgCC,MAAhC,EAAwC;AAC7C,MAAID,MAAM,KAAKC,MAAf,EAAuB;AAErB,WAAO,IAAP;AACD;;AAGD,MAAI,EAAED,MAAM,IAAIC,MAAZ,CAAJ,EAAyB;AACvB,WAAO,IAAP;AACD;;AAID,MAAI,EAAED,MAAM,IAAIC,MAAZ,CAAJ,EAAyB;AACvB,WAAO,KAAP;AACD;;AAID,MAAI,OAAOD,MAAP,KAAkB,OAAOC,MAA7B,EAAqC;AACnC,WAAO,KAAP;AACD;;AAGD,MAAI,OAAOD,MAAP,KAAkB,QAAlB,IAA8BA,MAAM,YAAYE,MAAhD,IACJ,OAAOD,MAAP,KAAkB,QADd,IAC0BA,MAAM,YAAYC,MADhD,EACwD;AAGtD,WAAO,KAAP;AACD;;AAGD,MAAIF,MAAM,CAACP,IAAP,KAAgBQ,MAAM,CAACR,IAA3B,EAAiC;AAC/B,WAAO,KAAP;AACD;;AAGD,MAAMU,WAAW,GAAGH,MAAM,CAAClD,KAAP,IAAgB,EAApC;AACA,MAAMsD,WAAW,GAAGH,MAAM,CAACnD,KAAP,IAAgB,EAApC;;AAEA,MAAIuD,IAAI,CAACC,SAAL,CAAeH,WAAf,MAAgCE,IAAI,CAACC,SAAL,CAAeF,WAAf,CAApC,EAAiE;AAC/D,WAAO,KAAP;AACD;;AAID,MAAI,EAAED,WAAW,CAACI,QAAZ,IAAwBH,WAAW,CAACG,QAAtC,CAAJ,EAAqD;AACnD,WAAO,IAAP;AACD;;AAGD,MAAI,EAAEJ,WAAW,CAACI,QAAZ,IAAwBH,WAAW,CAACG,QAAtC,CAAJ,EAAqD;AACnD,WAAO,KAAP;AACD;;AAID,MAAMC,aAAa,GAAGC,KAAK,CAACC,OAAN,CAAcP,WAAW,CAACI,QAA1B,CAAtB;AACA,MAAMI,aAAa,GAAGF,KAAK,CAACC,OAAN,CAAcN,WAAW,CAACG,QAA1B,CAAtB;;AAEA,MAAIC,aAAa,IAAIG,aAArB,EAAoC;AAClC,QAAMC,SAAS,GAAGT,WAAW,CAACI,QAA9B;AACA,QAAMM,SAAS,GAAGT,WAAW,CAACG,QAA9B;;AAEA,QAAIK,SAAS,CAACE,MAAV,KAAqBD,SAAS,CAACC,MAAnC,EAA2C;AACzC,aAAO,KAAP;AACD;;AAGD,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,SAAS,CAACE,MAA9B,EAAsCC,CAAC,EAAvC,EAA2C;AACzC,UAAI,CAAChB,cAAc,CAACa,SAAS,CAACG,CAAD,CAAV,EAAeF,SAAS,CAACE,CAAD,CAAxB,CAAnB,EAAiD;AAC/C,eAAO,KAAP;AACD;AACF;;AAED,WAAO,IAAP;AACD;;AAGD,MAAIP,aAAa,IAAIG,aAArB,EAAoC;AAClC,WAAO,KAAP;AACD;;AAGD,SAAOZ,cAAc,CAACI,WAAW,CAACI,QAAb,EAAuBH,WAAW,CAACG,QAAnC,CAArB;AACD","sourcesContent":["import { LABEL_PADDING_HORIZONTAL, ADORNMENT_OFFSET, ADORNMENT_SIZE, FLAT_INPUT_OFFSET } from './constants';\nimport { AdornmentType, AdornmentSide } from './Adornment/enums';\nexport const calculateLabelTopPosition = (labelHeight, height = 0, optionalPadding = 0) => {\n  const customHeight = height > 0 ? height : 0;\n  return Math.floor((customHeight - labelHeight) / 2 + optionalPadding);\n};\nexport const calculateInputHeight = (labelHeight, height = 0, minHeight) => {\n  const finalHeight = height > 0 ? height : labelHeight;\n  if (height > 0) return height;\n  return finalHeight < minHeight ? minHeight : finalHeight;\n};\nexport const calculatePadding = props => {\n  const {\n    height,\n    multiline = false\n  } = props;\n  let result = 0;\n\n  if (multiline) {\n    if (height && multiline) {\n      result = calculateTextAreaPadding(props);\n    } else {\n      result = calculateInputPadding(props);\n    }\n  }\n\n  return Math.max(0, result);\n};\n\nconst calculateTextAreaPadding = props => {\n  const {\n    dense\n  } = props;\n  return dense ? 10 : 20;\n};\n\nconst calculateInputPadding = ({\n  topPosition,\n  fontSize,\n  multiline,\n  scale,\n  dense,\n  offset,\n  isAndroid\n}) => {\n  const refFontSize = scale * fontSize;\n  let result = Math.floor(topPosition / 2);\n  result = result + Math.floor((refFontSize - fontSize) / 2) - (scale < 1 ? offset / 2 : 0);\n  if (multiline && isAndroid) result = Math.min(dense ? offset / 2 : offset, result);\n  return result;\n};\n\nexport const adjustPaddingOut = ({\n  pad,\n  multiline,\n  label,\n  scale,\n  height,\n  fontSize,\n  lineHeight,\n  dense,\n  offset,\n  isAndroid\n}) => {\n  const fontHeight = lineHeight !== null && lineHeight !== void 0 ? lineHeight : fontSize;\n  const refFontHeight = scale * fontSize;\n  let result = pad;\n\n  if (height && !multiline) {\n    return {\n      paddingTop: Math.max(0, (height - fontHeight) / 2),\n      paddingBottom: Math.max(0, (height - fontHeight) / 2)\n    };\n  }\n\n  if (!isAndroid && multiline) {\n    if (dense) {\n      if (label) {\n        result += scale < 1 ? Math.min(offset, refFontHeight / 2 * scale) : 0;\n      } else {\n        result += 0;\n      }\n    }\n\n    if (!dense) {\n      if (label) {\n        result += scale < 1 ? Math.min(offset, refFontHeight * scale) : Math.min(offset / 2, refFontHeight * scale);\n      } else {\n        result += scale < 1 ? Math.min(offset / 2, refFontHeight * scale) : 0;\n      }\n    }\n\n    result = Math.floor(result);\n  }\n\n  return {\n    paddingTop: result,\n    paddingBottom: result\n  };\n};\nexport const adjustPaddingFlat = ({\n  pad,\n  scale,\n  multiline,\n  label,\n  height,\n  offset,\n  dense,\n  fontSize,\n  isAndroid,\n  styles\n}) => {\n  let result = pad;\n  let topResult = result;\n  let bottomResult = result;\n  const {\n    paddingTop,\n    paddingBottom\n  } = styles;\n  const refFontSize = scale * fontSize;\n\n  if (!multiline) {\n    // do not modify padding if input is not multiline\n    if (label) {\n      // return const style for flat input with label\n      return {\n        paddingTop,\n        paddingBottom\n      };\n    } // return pad for flat input without label\n\n\n    return {\n      paddingTop: result,\n      paddingBottom: result\n    };\n  }\n\n  if (label) {\n    // add paddings passed from styles\n    topResult = paddingTop;\n    bottomResult = paddingBottom; // adjust top padding for iOS\n\n    if (!isAndroid) {\n      if (dense) {\n        topResult += scale < 1 ? Math.min(result, refFontSize * scale) - result / 2 : Math.min(result, refFontSize * scale) - result / 2;\n      }\n\n      if (!dense) {\n        topResult += scale < 1 ? Math.min(offset / 2, refFontSize * scale) : Math.min(result, refFontSize * scale) - offset / 2;\n      }\n    }\n\n    topResult = Math.floor(topResult);\n  } else {\n    if (height) {\n      // center text when height is passed\n      return {\n        paddingTop: Math.max(0, (height - fontSize) / 2),\n        paddingBottom: Math.max(0, (height - fontSize) / 2)\n      };\n    } // adjust paddings for iOS if no label\n\n\n    if (!isAndroid) {\n      if (dense) {\n        result += scale < 1 ? Math.min(offset / 2, fontSize / 2 * scale) : Math.min(offset / 2, scale);\n      }\n\n      if (!dense) {\n        result += scale < 1 ? Math.min(offset, fontSize * scale) : Math.min(fontSize, offset / 2 * scale);\n      }\n\n      result = Math.floor(result);\n      topResult = result;\n      bottomResult = result;\n    }\n  }\n\n  return {\n    paddingTop: Math.max(0, topResult),\n    paddingBottom: Math.max(0, bottomResult)\n  };\n};\nexport const interpolatePlaceholder = (labeled, hasActiveOutline) => labeled.interpolate({\n  inputRange: [0, 1],\n  outputRange: [hasActiveOutline ? 0 : 1, 1]\n});\nexport function calculateFlatAffixTopPosition({\n  height,\n  paddingTop,\n  paddingBottom,\n  affixHeight\n}) {\n  const inputHeightWithoutPadding = height - paddingTop - paddingBottom;\n  const halfOfTheInputHeightDecreasedByAffixHeight = (inputHeightWithoutPadding - affixHeight) / 2;\n  return paddingTop + halfOfTheInputHeightDecreasedByAffixHeight;\n}\nexport function calculateOutlinedIconAndAffixTopPosition({\n  height,\n  affixHeight,\n  labelYOffset\n}) {\n  return (height - affixHeight + labelYOffset) / 2;\n}\nexport const calculateFlatInputHorizontalPadding = ({\n  adornmentConfig\n}) => {\n  let paddingLeft = LABEL_PADDING_HORIZONTAL;\n  let paddingRight = LABEL_PADDING_HORIZONTAL;\n  adornmentConfig.forEach(({\n    type,\n    side\n  }) => {\n    if (type === AdornmentType.Icon && side === AdornmentSide.Left) {\n      paddingLeft = ADORNMENT_SIZE + ADORNMENT_OFFSET + FLAT_INPUT_OFFSET;\n    } else if (side === AdornmentSide.Right) {\n      if (type === AdornmentType.Affix) {\n        paddingRight = ADORNMENT_SIZE + ADORNMENT_OFFSET + FLAT_INPUT_OFFSET;\n      } else if (type === AdornmentType.Icon) {\n        paddingRight = ADORNMENT_SIZE + ADORNMENT_OFFSET + FLAT_INPUT_OFFSET;\n      }\n    }\n  });\n  return {\n    paddingLeft,\n    paddingRight\n  };\n};\nexport function areLabelsEqual(label1, label2) {\n  if (label1 === label2) {\n    // will also take care of equality for `string` type, or if both are undefined.\n    return true;\n  } // Return true if both of them are falsy.\n\n\n  if (!(label1 || label2)) {\n    return true;\n  } // At this point, both of them cannot be false.\n  // So, return false if any of them is falsy.\n\n\n  if (!(label1 && label2)) {\n    return false;\n  } // At this point, both of them has to be truthy.\n  // So, return false if they are not of the same type.\n\n\n  if (typeof label1 !== typeof label2) {\n    return false;\n  } // At this point, both of them has to be of the same datatype.\n\n\n  if (typeof label1 === 'string' || label1 instanceof String || // These last two OR checks are only here for Typescript's sake.\n  typeof label2 === 'string' || label2 instanceof String) {\n    // They're strings, so they won't be equal; otherwise\n    //  we would have returned 'true' earlier.\n    return false;\n  } // At this point, both of them has to be of the datatype: `React.ReactElement`.\n\n\n  if (label1.type !== label2.type) {\n    return false;\n  } // Preliminary equality check: do they stringify to the same string?\n\n\n  const label1Props = label1.props || {};\n  const label2Props = label2.props || {};\n\n  if (JSON.stringify(label1Props) !== JSON.stringify(label2Props)) {\n    return false;\n  } // We now know they stringify to the same string.\n  // Return true if both of them DO NOT have children\n\n\n  if (!(label1Props.children || label2Props.children)) {\n    return true; // since there's nothing else to check\n  } // Return false if only one of them has children\n\n\n  if (!(label1Props.children && label2Props.children)) {\n    return false;\n  } // Both have children...\n  // Handle for when both the children are arrays\n\n\n  const label1IsArray = Array.isArray(label1Props.children);\n  const label2IsArray = Array.isArray(label2Props.children);\n\n  if (label1IsArray && label2IsArray) {\n    const children1 = label1Props.children;\n    const children2 = label2Props.children;\n\n    if (children1.length !== children2.length) {\n      return false; // no point proceeding\n    } // all the children must also be equal\n\n\n    for (let i = 0; i < children1.length; i++) {\n      if (!areLabelsEqual(children1[i], children2[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  } // Only one of them can be an array at this point. If any is array, return false\n\n\n  if (label1IsArray || label2IsArray) {\n    return false;\n  } // both children are not arrays, so recur.\n\n\n  return areLabelsEqual(label1Props.children, label2Props.children);\n}\n//# sourceMappingURL=helpers.js.map"]},"metadata":{},"sourceType":"module"}