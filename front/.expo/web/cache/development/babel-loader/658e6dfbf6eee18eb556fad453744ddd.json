{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nvar _excluded = [\"uri\"];\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport { PermissionStatus, SyntheticPlatformEmitter } from 'expo-modules-core';\nimport { RECORDING_OPTIONS_PRESET_HIGH_QUALITY } from \"./Audio/RecordingConstants\";\n\nfunction getPermissionWithQueryAsync(name) {\n  var _await$navigator$perm, state;\n\n  return _regeneratorRuntime.async(function getPermissionWithQueryAsync$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          if (!(!navigator || !navigator.permissions || !navigator.permissions.query)) {\n            _context.next = 2;\n            break;\n          }\n\n          return _context.abrupt(\"return\", null);\n\n        case 2:\n          _context.prev = 2;\n          _context.next = 5;\n          return _regeneratorRuntime.awrap(navigator.permissions.query({\n            name: name\n          }));\n\n        case 5:\n          _await$navigator$perm = _context.sent;\n          state = _await$navigator$perm.state;\n          _context.t0 = state;\n          _context.next = _context.t0 === 'granted' ? 10 : _context.t0 === 'denied' ? 11 : 12;\n          break;\n\n        case 10:\n          return _context.abrupt(\"return\", PermissionStatus.GRANTED);\n\n        case 11:\n          return _context.abrupt(\"return\", PermissionStatus.DENIED);\n\n        case 12:\n          return _context.abrupt(\"return\", PermissionStatus.UNDETERMINED);\n\n        case 13:\n          _context.next = 18;\n          break;\n\n        case 15:\n          _context.prev = 15;\n          _context.t1 = _context[\"catch\"](2);\n          return _context.abrupt(\"return\", PermissionStatus.UNDETERMINED);\n\n        case 18:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, [[2, 15]], Promise);\n}\n\nfunction getUserMedia(constraints) {\n  if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n    return navigator.mediaDevices.getUserMedia(constraints);\n  }\n\n  var getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || function () {\n    var error = new Error('Permission unimplemented');\n    error.code = 0;\n    error.name = 'NotAllowedError';\n    throw error;\n  };\n\n  return new Promise(function (resolve, reject) {\n    getUserMedia.call(navigator, constraints, resolve, reject);\n  });\n}\n\nfunction getStatusFromMedia(media) {\n  if (!media) {\n    return {\n      isLoaded: false,\n      error: undefined\n    };\n  }\n\n  var isPlaying = !!(media.currentTime > 0 && !media.paused && !media.ended && media.readyState > 2);\n  var status = {\n    isLoaded: true,\n    uri: media.src,\n    progressUpdateIntervalMillis: 100,\n    durationMillis: media.duration * 1000,\n    positionMillis: media.currentTime * 1000,\n    shouldPlay: media.autoplay,\n    isPlaying: isPlaying,\n    isBuffering: false,\n    rate: media.playbackRate,\n    shouldCorrectPitch: false,\n    volume: media.volume,\n    isMuted: media.muted,\n    isLooping: media.loop,\n    didJustFinish: media.ended\n  };\n  return status;\n}\n\nfunction setStatusForMedia(media, status) {\n  if (status.positionMillis !== undefined) {\n    media.currentTime = status.positionMillis / 1000;\n  }\n\n  if (status.shouldPlay !== undefined) {\n    if (status.shouldPlay) {\n      media.play();\n    } else {\n      media.pause();\n    }\n  }\n\n  if (status.rate !== undefined) {\n    media.playbackRate = status.rate;\n  }\n\n  if (status.volume !== undefined) {\n    media.volume = status.volume;\n  }\n\n  if (status.isMuted !== undefined) {\n    media.muted = status.isMuted;\n  }\n\n  if (status.isLooping !== undefined) {\n    media.loop = status.isLooping;\n  }\n\n  return getStatusFromMedia(media);\n}\n\nvar mediaRecorder = null;\nvar mediaRecorderUptimeOfLastStartResume = 0;\nvar mediaRecorderDurationAlreadyRecorded = 0;\nvar mediaRecorderIsRecording = false;\n\nfunction getAudioRecorderDurationMillis() {\n  var duration = mediaRecorderDurationAlreadyRecorded;\n\n  if (mediaRecorderIsRecording && mediaRecorderUptimeOfLastStartResume > 0) {\n    duration += Date.now() - mediaRecorderUptimeOfLastStartResume;\n  }\n\n  return duration;\n}\n\nexport default {\n  get name() {\n    return 'ExponentAV';\n  },\n\n  getStatusForVideo: function getStatusForVideo(element) {\n    return _regeneratorRuntime.async(function getStatusForVideo$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            return _context2.abrupt(\"return\", getStatusFromMedia(element));\n\n          case 1:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  },\n  loadForVideo: function loadForVideo(element, nativeSource, fullInitialStatus) {\n    return _regeneratorRuntime.async(function loadForVideo$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            return _context3.abrupt(\"return\", getStatusFromMedia(element));\n\n          case 1:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  },\n  unloadForVideo: function unloadForVideo(element) {\n    return _regeneratorRuntime.async(function unloadForVideo$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            return _context4.abrupt(\"return\", getStatusFromMedia(element));\n\n          case 1:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  },\n  setStatusForVideo: function setStatusForVideo(element, status) {\n    return _regeneratorRuntime.async(function setStatusForVideo$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            return _context5.abrupt(\"return\", setStatusForMedia(element, status));\n\n          case 1:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  },\n  replayVideo: function replayVideo(element, status) {\n    return _regeneratorRuntime.async(function replayVideo$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            return _context6.abrupt(\"return\", setStatusForMedia(element, status));\n\n          case 1:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  },\n  setAudioMode: function setAudioMode() {\n    return _regeneratorRuntime.async(function setAudioMode$(_context7) {\n      while (1) {\n        switch (_context7.prev = _context7.next) {\n          case 0:\n          case \"end\":\n            return _context7.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  },\n  setAudioIsEnabled: function setAudioIsEnabled() {\n    return _regeneratorRuntime.async(function setAudioIsEnabled$(_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n          case \"end\":\n            return _context8.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  },\n  getStatusForSound: function getStatusForSound(element) {\n    return _regeneratorRuntime.async(function getStatusForSound$(_context9) {\n      while (1) {\n        switch (_context9.prev = _context9.next) {\n          case 0:\n            return _context9.abrupt(\"return\", getStatusFromMedia(element));\n\n          case 1:\n          case \"end\":\n            return _context9.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  },\n  loadForSound: function loadForSound(nativeSource, fullInitialStatus) {\n    var source, media, status;\n    return _regeneratorRuntime.async(function loadForSound$(_context10) {\n      while (1) {\n        switch (_context10.prev = _context10.next) {\n          case 0:\n            source = typeof nativeSource === 'string' ? nativeSource : nativeSource.uri;\n            media = new Audio(source);\n\n            media.ontimeupdate = function () {\n              SyntheticPlatformEmitter.emit('didUpdatePlaybackStatus', {\n                key: media,\n                status: getStatusFromMedia(media)\n              });\n            };\n\n            media.onerror = function () {\n              SyntheticPlatformEmitter.emit('ExponentAV.onError', {\n                key: media,\n                error: media.error.message\n              });\n            };\n\n            status = setStatusForMedia(media, fullInitialStatus);\n            return _context10.abrupt(\"return\", [media, status]);\n\n          case 6:\n          case \"end\":\n            return _context10.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  },\n  unloadForSound: function unloadForSound(element) {\n    return _regeneratorRuntime.async(function unloadForSound$(_context11) {\n      while (1) {\n        switch (_context11.prev = _context11.next) {\n          case 0:\n            element.pause();\n            element.removeAttribute('src');\n            element.load();\n            return _context11.abrupt(\"return\", getStatusFromMedia(element));\n\n          case 4:\n          case \"end\":\n            return _context11.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  },\n  setStatusForSound: function setStatusForSound(element, status) {\n    return _regeneratorRuntime.async(function setStatusForSound$(_context12) {\n      while (1) {\n        switch (_context12.prev = _context12.next) {\n          case 0:\n            return _context12.abrupt(\"return\", setStatusForMedia(element, status));\n\n          case 1:\n          case \"end\":\n            return _context12.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  },\n  replaySound: function replaySound(element, status) {\n    return _regeneratorRuntime.async(function replaySound$(_context13) {\n      while (1) {\n        switch (_context13.prev = _context13.next) {\n          case 0:\n            return _context13.abrupt(\"return\", setStatusForMedia(element, status));\n\n          case 1:\n          case \"end\":\n            return _context13.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  },\n  getAudioRecordingStatus: function getAudioRecordingStatus() {\n    var _mediaRecorder, _mediaRecorder2, _mediaRecorder3;\n\n    return _regeneratorRuntime.async(function getAudioRecordingStatus$(_context14) {\n      while (1) {\n        switch (_context14.prev = _context14.next) {\n          case 0:\n            return _context14.abrupt(\"return\", {\n              canRecord: ((_mediaRecorder = mediaRecorder) == null ? void 0 : _mediaRecorder.state) === 'recording' || ((_mediaRecorder2 = mediaRecorder) == null ? void 0 : _mediaRecorder2.state) === 'inactive',\n              isRecording: ((_mediaRecorder3 = mediaRecorder) == null ? void 0 : _mediaRecorder3.state) === 'recording',\n              isDoneRecording: false,\n              durationMillis: getAudioRecorderDurationMillis(),\n              uri: null\n            });\n\n          case 1:\n          case \"end\":\n            return _context14.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  },\n  prepareAudioRecorder: function prepareAudioRecorder(options) {\n    var stream, _await$this$getAudioR, uri, status;\n\n    return _regeneratorRuntime.async(function prepareAudioRecorder$(_context15) {\n      while (1) {\n        switch (_context15.prev = _context15.next) {\n          case 0:\n            if (!(typeof navigator !== 'undefined' && !navigator.mediaDevices)) {\n              _context15.next = 2;\n              break;\n            }\n\n            throw new Error('No media devices available');\n\n          case 2:\n            mediaRecorderUptimeOfLastStartResume = 0;\n            mediaRecorderDurationAlreadyRecorded = 0;\n            _context15.next = 6;\n            return _regeneratorRuntime.awrap(getUserMedia({\n              audio: true\n            }));\n\n          case 6:\n            stream = _context15.sent;\n            mediaRecorder = new window.MediaRecorder(stream, (options == null ? void 0 : options.web) || RECORDING_OPTIONS_PRESET_HIGH_QUALITY.web);\n            mediaRecorder.addEventListener('pause', function () {\n              mediaRecorderDurationAlreadyRecorded = getAudioRecorderDurationMillis();\n              mediaRecorderIsRecording = false;\n            });\n            mediaRecorder.addEventListener('resume', function () {\n              mediaRecorderUptimeOfLastStartResume = Date.now();\n              mediaRecorderIsRecording = true;\n            });\n            mediaRecorder.addEventListener('start', function () {\n              mediaRecorderUptimeOfLastStartResume = Date.now();\n              mediaRecorderDurationAlreadyRecorded = 0;\n              mediaRecorderIsRecording = true;\n            });\n            mediaRecorder.addEventListener('stop', function () {\n              mediaRecorderDurationAlreadyRecorded = getAudioRecorderDurationMillis();\n              mediaRecorderIsRecording = false;\n              stream.getTracks().forEach(function (track) {\n                return track.stop();\n              });\n            });\n            _context15.next = 14;\n            return _regeneratorRuntime.awrap(this.getAudioRecordingStatus());\n\n          case 14:\n            _await$this$getAudioR = _context15.sent;\n            uri = _await$this$getAudioR.uri;\n            status = _objectWithoutProperties(_await$this$getAudioR, _excluded);\n            return _context15.abrupt(\"return\", {\n              uri: null,\n              status: status\n            });\n\n          case 18:\n          case \"end\":\n            return _context15.stop();\n        }\n      }\n    }, null, this, null, Promise);\n  },\n  startAudioRecording: function startAudioRecording() {\n    return _regeneratorRuntime.async(function startAudioRecording$(_context16) {\n      while (1) {\n        switch (_context16.prev = _context16.next) {\n          case 0:\n            if (!(mediaRecorder === null)) {\n              _context16.next = 2;\n              break;\n            }\n\n            throw new Error('Cannot start an audio recording without initializing a MediaRecorder. Run prepareToRecordAsync() before attempting to start an audio recording.');\n\n          case 2:\n            if (mediaRecorder.state === 'paused') {\n              mediaRecorder.resume();\n            } else {\n              mediaRecorder.start();\n            }\n\n            return _context16.abrupt(\"return\", this.getAudioRecordingStatus());\n\n          case 4:\n          case \"end\":\n            return _context16.stop();\n        }\n      }\n    }, null, this, null, Promise);\n  },\n  pauseAudioRecording: function pauseAudioRecording() {\n    return _regeneratorRuntime.async(function pauseAudioRecording$(_context17) {\n      while (1) {\n        switch (_context17.prev = _context17.next) {\n          case 0:\n            if (!(mediaRecorder === null)) {\n              _context17.next = 2;\n              break;\n            }\n\n            throw new Error('Cannot start an audio recording without initializing a MediaRecorder. Run prepareToRecordAsync() before attempting to start an audio recording.');\n\n          case 2:\n            mediaRecorder.pause();\n            return _context17.abrupt(\"return\", this.getAudioRecordingStatus());\n\n          case 4:\n          case \"end\":\n            return _context17.stop();\n        }\n      }\n    }, null, this, null, Promise);\n  },\n  stopAudioRecording: function stopAudioRecording() {\n    var dataPromise, data, url;\n    return _regeneratorRuntime.async(function stopAudioRecording$(_context18) {\n      while (1) {\n        switch (_context18.prev = _context18.next) {\n          case 0:\n            if (!(mediaRecorder === null)) {\n              _context18.next = 2;\n              break;\n            }\n\n            throw new Error('Cannot start an audio recording without initializing a MediaRecorder. Run prepareToRecordAsync() before attempting to start an audio recording.');\n\n          case 2:\n            if (!(mediaRecorder.state === 'inactive')) {\n              _context18.next = 4;\n              break;\n            }\n\n            return _context18.abrupt(\"return\", this.getAudioRecordingStatus());\n\n          case 4:\n            dataPromise = new Promise(function (resolve) {\n              return mediaRecorder.addEventListener('dataavailable', function (e) {\n                return resolve(e.data);\n              });\n            });\n            mediaRecorder.stop();\n            _context18.next = 8;\n            return _regeneratorRuntime.awrap(dataPromise);\n\n          case 8:\n            data = _context18.sent;\n            url = URL.createObjectURL(data);\n            _context18.t0 = _objectSpread;\n            _context18.t1 = _objectSpread;\n            _context18.t2 = {};\n            _context18.next = 15;\n            return _regeneratorRuntime.awrap(this.getAudioRecordingStatus());\n\n          case 15:\n            _context18.t3 = _context18.sent;\n            _context18.t4 = (0, _context18.t1)(_context18.t2, _context18.t3);\n            _context18.t5 = {};\n            _context18.t6 = {\n              uri: url\n            };\n            return _context18.abrupt(\"return\", (0, _context18.t0)(_context18.t4, _context18.t5, _context18.t6));\n\n          case 20:\n          case \"end\":\n            return _context18.stop();\n        }\n      }\n    }, null, this, null, Promise);\n  },\n  unloadAudioRecorder: function unloadAudioRecorder() {\n    return _regeneratorRuntime.async(function unloadAudioRecorder$(_context19) {\n      while (1) {\n        switch (_context19.prev = _context19.next) {\n          case 0:\n            mediaRecorder = null;\n\n          case 1:\n          case \"end\":\n            return _context19.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  },\n  getPermissionsAsync: function getPermissionsAsync() {\n    var maybeStatus;\n    return _regeneratorRuntime.async(function getPermissionsAsync$(_context20) {\n      while (1) {\n        switch (_context20.prev = _context20.next) {\n          case 0:\n            _context20.next = 2;\n            return _regeneratorRuntime.awrap(getPermissionWithQueryAsync('microphone'));\n\n          case 2:\n            maybeStatus = _context20.sent;\n            _context20.t0 = maybeStatus;\n            _context20.next = _context20.t0 === PermissionStatus.GRANTED ? 6 : _context20.t0 === PermissionStatus.DENIED ? 7 : 8;\n            break;\n\n          case 6:\n            return _context20.abrupt(\"return\", {\n              status: PermissionStatus.GRANTED,\n              expires: 'never',\n              canAskAgain: true,\n              granted: true\n            });\n\n          case 7:\n            return _context20.abrupt(\"return\", {\n              status: PermissionStatus.DENIED,\n              expires: 'never',\n              canAskAgain: true,\n              granted: false\n            });\n\n          case 8:\n            _context20.next = 10;\n            return _regeneratorRuntime.awrap(this.requestPermissionsAsync());\n\n          case 10:\n            return _context20.abrupt(\"return\", _context20.sent);\n\n          case 11:\n          case \"end\":\n            return _context20.stop();\n        }\n      }\n    }, null, this, null, Promise);\n  },\n  requestPermissionsAsync: function requestPermissionsAsync() {\n    var stream;\n    return _regeneratorRuntime.async(function requestPermissionsAsync$(_context21) {\n      while (1) {\n        switch (_context21.prev = _context21.next) {\n          case 0:\n            _context21.prev = 0;\n            _context21.next = 3;\n            return _regeneratorRuntime.awrap(getUserMedia({\n              audio: true\n            }));\n\n          case 3:\n            stream = _context21.sent;\n            stream.getTracks().forEach(function (track) {\n              return track.stop();\n            });\n            return _context21.abrupt(\"return\", {\n              status: PermissionStatus.GRANTED,\n              expires: 'never',\n              canAskAgain: true,\n              granted: true\n            });\n\n          case 8:\n            _context21.prev = 8;\n            _context21.t0 = _context21[\"catch\"](0);\n            return _context21.abrupt(\"return\", {\n              status: PermissionStatus.DENIED,\n              expires: 'never',\n              canAskAgain: true,\n              granted: false\n            });\n\n          case 11:\n          case \"end\":\n            return _context21.stop();\n        }\n      }\n    }, null, null, [[0, 8]], Promise);\n  }\n};","map":{"version":3,"mappings":"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","names":["PermissionStatus","SyntheticPlatformEmitter","RECORDING_OPTIONS_PRESET_HIGH_QUALITY","getPermissionWithQueryAsync","name","navigator","permissions","query","state","GRANTED","DENIED","UNDETERMINED","getUserMedia","constraints","mediaDevices","webkitGetUserMedia","mozGetUserMedia","error","Error","code","Promise","resolve","reject","call","getStatusFromMedia","media","isLoaded","undefined","isPlaying","currentTime","paused","ended","readyState","status","uri","src","progressUpdateIntervalMillis","durationMillis","duration","positionMillis","shouldPlay","autoplay","isBuffering","rate","playbackRate","shouldCorrectPitch","volume","isMuted","muted","isLooping","loop","didJustFinish","setStatusForMedia","play","pause","mediaRecorder","mediaRecorderUptimeOfLastStartResume","mediaRecorderDurationAlreadyRecorded","mediaRecorderIsRecording","getAudioRecorderDurationMillis","Date","now","getStatusForVideo","element","loadForVideo","nativeSource","fullInitialStatus","unloadForVideo","setStatusForVideo","replayVideo","setAudioMode","setAudioIsEnabled","getStatusForSound","loadForSound","source","Audio","ontimeupdate","emit","key","onerror","message","unloadForSound","removeAttribute","load","setStatusForSound","replaySound","getAudioRecordingStatus","canRecord","isRecording","isDoneRecording","prepareAudioRecorder","options","audio","stream","window","MediaRecorder","web","addEventListener","getTracks","forEach","track","stop","startAudioRecording","resume","start","pauseAudioRecording","stopAudioRecording","dataPromise","e","data","url","URL","createObjectURL","unloadAudioRecorder","getPermissionsAsync","maybeStatus","expires","canAskAgain","granted","requestPermissionsAsync"],"sourceRoot":"","sources":["../src/ExponentAV.web.ts"],"sourcesContent":["import { PermissionResponse, PermissionStatus, SyntheticPlatformEmitter } from 'expo-modules-core';\n\nimport type { AVPlaybackNativeSource, AVPlaybackStatus, AVPlaybackStatusToSet } from './AV.types';\nimport type { RecordingStatus } from './Audio/Recording.types';\nimport { RECORDING_OPTIONS_PRESET_HIGH_QUALITY } from './Audio/RecordingConstants';\n\nasync function getPermissionWithQueryAsync(\n  name: PermissionNameWithAdditionalValues\n): Promise<PermissionStatus | null> {\n  if (!navigator || !navigator.permissions || !navigator.permissions.query) return null;\n\n  try {\n    const { state } = await navigator.permissions.query({ name });\n    switch (state) {\n      case 'granted':\n        return PermissionStatus.GRANTED;\n      case 'denied':\n        return PermissionStatus.DENIED;\n      default:\n        return PermissionStatus.UNDETERMINED;\n    }\n  } catch (error) {\n    // FireFox - TypeError: 'microphone' (value of 'name' member of PermissionDescriptor) is not a valid value for enumeration PermissionName.\n    return PermissionStatus.UNDETERMINED;\n  }\n}\n\nfunction getUserMedia(constraints: MediaStreamConstraints): Promise<MediaStream> {\n  if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n    return navigator.mediaDevices.getUserMedia(constraints);\n  }\n\n  // Some browsers partially implement mediaDevices. We can't just assign an object\n  // with getUserMedia as it would overwrite existing properties.\n  // Here, we will just add the getUserMedia property if it's missing.\n\n  // First get ahold of the legacy getUserMedia, if present\n  const getUserMedia =\n    // TODO: this method is deprecated, migrate to https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia\n    navigator.getUserMedia ||\n    navigator.webkitGetUserMedia ||\n    navigator.mozGetUserMedia ||\n    function () {\n      const error: any = new Error('Permission unimplemented');\n      error.code = 0;\n      error.name = 'NotAllowedError';\n      throw error;\n    };\n\n  return new Promise((resolve, reject) => {\n    getUserMedia.call(navigator, constraints, resolve, reject);\n  });\n}\n\nfunction getStatusFromMedia(media?: HTMLMediaElement): AVPlaybackStatus {\n  if (!media) {\n    return {\n      isLoaded: false,\n      error: undefined,\n    };\n  }\n\n  const isPlaying = !!(\n    media.currentTime > 0 &&\n    !media.paused &&\n    !media.ended &&\n    media.readyState > 2\n  );\n\n  const status: AVPlaybackStatus = {\n    isLoaded: true,\n    uri: media.src,\n    progressUpdateIntervalMillis: 100, //TODO: Bacon: Add interval between calls\n    durationMillis: media.duration * 1000,\n    positionMillis: media.currentTime * 1000,\n    // playableDurationMillis: media.buffered * 1000,\n    // seekMillisToleranceBefore?: number\n    // seekMillisToleranceAfter?: number\n    shouldPlay: media.autoplay,\n    isPlaying,\n    isBuffering: false, //media.waiting,\n    rate: media.playbackRate,\n    // TODO: Bacon: This seems too complicated right now: https://webaudio.github.io/web-audio-api/#dom-biquadfilternode-frequency\n    shouldCorrectPitch: false,\n    volume: media.volume,\n    isMuted: media.muted,\n    isLooping: media.loop,\n    didJustFinish: media.ended,\n  };\n\n  return status;\n}\n\nfunction setStatusForMedia(\n  media: HTMLMediaElement,\n  status: AVPlaybackStatusToSet\n): AVPlaybackStatus {\n  if (status.positionMillis !== undefined) {\n    media.currentTime = status.positionMillis / 1000;\n  }\n  // if (status.progressUpdateIntervalMillis !== undefined) {\n  //   media.progressUpdateIntervalMillis = status.progressUpdateIntervalMillis;\n  // }\n  // if (status.seekMillisToleranceBefore !== undefined) {\n  //   media.seekMillisToleranceBefore = status.seekMillisToleranceBefore;\n  // }\n  // if (status.seekMillisToleranceAfter !== undefined) {\n  //   media.seekMillisToleranceAfter = status.seekMillisToleranceAfter;\n  // }\n  // if (status.shouldCorrectPitch !== undefined) {\n  //   media.shouldCorrectPitch = status.shouldCorrectPitch;\n  // }\n  if (status.shouldPlay !== undefined) {\n    if (status.shouldPlay) {\n      media.play();\n    } else {\n      media.pause();\n    }\n  }\n  if (status.rate !== undefined) {\n    media.playbackRate = status.rate;\n  }\n  if (status.volume !== undefined) {\n    media.volume = status.volume;\n  }\n  if (status.isMuted !== undefined) {\n    media.muted = status.isMuted;\n  }\n  if (status.isLooping !== undefined) {\n    media.loop = status.isLooping;\n  }\n\n  return getStatusFromMedia(media);\n}\n\nlet mediaRecorder: null | any /*MediaRecorder*/ = null;\nlet mediaRecorderUptimeOfLastStartResume: number = 0;\nlet mediaRecorderDurationAlreadyRecorded: number = 0;\nlet mediaRecorderIsRecording: boolean = false;\n\nfunction getAudioRecorderDurationMillis() {\n  let duration = mediaRecorderDurationAlreadyRecorded;\n  if (mediaRecorderIsRecording && mediaRecorderUptimeOfLastStartResume > 0) {\n    duration += Date.now() - mediaRecorderUptimeOfLastStartResume;\n  }\n  return duration;\n}\n\nexport default {\n  get name(): string {\n    return 'ExponentAV';\n  },\n  async getStatusForVideo(element: HTMLMediaElement): Promise<AVPlaybackStatus> {\n    return getStatusFromMedia(element);\n  },\n  async loadForVideo(\n    element: HTMLMediaElement,\n    nativeSource: AVPlaybackNativeSource,\n    fullInitialStatus: AVPlaybackStatusToSet\n  ): Promise<AVPlaybackStatus> {\n    return getStatusFromMedia(element);\n  },\n  async unloadForVideo(element: HTMLMediaElement): Promise<AVPlaybackStatus> {\n    return getStatusFromMedia(element);\n  },\n  async setStatusForVideo(\n    element: HTMLMediaElement,\n    status: AVPlaybackStatusToSet\n  ): Promise<AVPlaybackStatus> {\n    return setStatusForMedia(element, status);\n  },\n  async replayVideo(\n    element: HTMLMediaElement,\n    status: AVPlaybackStatusToSet\n  ): Promise<AVPlaybackStatus> {\n    return setStatusForMedia(element, status);\n  },\n  /* Audio */\n  async setAudioMode() {},\n  async setAudioIsEnabled() {},\n  async getStatusForSound(element: HTMLMediaElement) {\n    return getStatusFromMedia(element);\n  },\n  async loadForSound(\n    nativeSource: string | { uri: string; [key: string]: any },\n    fullInitialStatus: AVPlaybackStatusToSet\n  ): Promise<[HTMLMediaElement, AVPlaybackStatus]> {\n    const source = typeof nativeSource === 'string' ? nativeSource : nativeSource.uri;\n    const media = new Audio(source);\n\n    media.ontimeupdate = () => {\n      SyntheticPlatformEmitter.emit('didUpdatePlaybackStatus', {\n        key: media,\n        status: getStatusFromMedia(media),\n      });\n    };\n\n    media.onerror = () => {\n      SyntheticPlatformEmitter.emit('ExponentAV.onError', {\n        key: media,\n        error: media.error!.message,\n      });\n    };\n\n    const status = setStatusForMedia(media, fullInitialStatus);\n\n    return [media, status];\n  },\n  async unloadForSound(element: HTMLMediaElement) {\n    element.pause();\n    element.removeAttribute('src');\n    element.load();\n    return getStatusFromMedia(element);\n  },\n  async setStatusForSound(\n    element: HTMLMediaElement,\n    status: AVPlaybackStatusToSet\n  ): Promise<AVPlaybackStatus> {\n    return setStatusForMedia(element, status);\n  },\n  async replaySound(\n    element: HTMLMediaElement,\n    status: AVPlaybackStatusToSet\n  ): Promise<AVPlaybackStatus> {\n    return setStatusForMedia(element, status);\n  },\n\n  /* Recording */\n  //   async setUnloadedCallbackForAndroidRecording() {},\n  async getAudioRecordingStatus(): Promise<RecordingStatus> {\n    return {\n      canRecord: mediaRecorder?.state === 'recording' || mediaRecorder?.state === 'inactive',\n      isRecording: mediaRecorder?.state === 'recording',\n      isDoneRecording: false,\n      durationMillis: getAudioRecorderDurationMillis(),\n      uri: null,\n    };\n  },\n  async prepareAudioRecorder(options): Promise<{\n    uri: string | null;\n    // status is of type RecordingStatus, but without the canRecord field populated\n    status: Pick<RecordingStatus, Exclude<keyof RecordingStatus, 'canRecord'>>;\n  }> {\n    if (typeof navigator !== 'undefined' && !navigator.mediaDevices) {\n      throw new Error('No media devices available');\n    }\n\n    mediaRecorderUptimeOfLastStartResume = 0;\n    mediaRecorderDurationAlreadyRecorded = 0;\n\n    const stream = await getUserMedia({ audio: true });\n\n    mediaRecorder = new (window as any).MediaRecorder(\n      stream,\n      options?.web || RECORDING_OPTIONS_PRESET_HIGH_QUALITY.web\n    );\n\n    mediaRecorder.addEventListener('pause', () => {\n      mediaRecorderDurationAlreadyRecorded = getAudioRecorderDurationMillis();\n      mediaRecorderIsRecording = false;\n    });\n\n    mediaRecorder.addEventListener('resume', () => {\n      mediaRecorderUptimeOfLastStartResume = Date.now();\n      mediaRecorderIsRecording = true;\n    });\n\n    mediaRecorder.addEventListener('start', () => {\n      mediaRecorderUptimeOfLastStartResume = Date.now();\n      mediaRecorderDurationAlreadyRecorded = 0;\n      mediaRecorderIsRecording = true;\n    });\n\n    mediaRecorder.addEventListener('stop', () => {\n      mediaRecorderDurationAlreadyRecorded = getAudioRecorderDurationMillis();\n      mediaRecorderIsRecording = false;\n\n      // Clears recording icon in Chrome tab\n      stream.getTracks().forEach((track) => track.stop());\n    });\n\n    const { uri, ...status } = await this.getAudioRecordingStatus();\n\n    return { uri: null, status };\n  },\n  async startAudioRecording(): Promise<RecordingStatus> {\n    if (mediaRecorder === null) {\n      throw new Error(\n        'Cannot start an audio recording without initializing a MediaRecorder. Run prepareToRecordAsync() before attempting to start an audio recording.'\n      );\n    }\n\n    if (mediaRecorder.state === 'paused') {\n      mediaRecorder.resume();\n    } else {\n      mediaRecorder.start();\n    }\n\n    return this.getAudioRecordingStatus();\n  },\n  async pauseAudioRecording(): Promise<RecordingStatus> {\n    if (mediaRecorder === null) {\n      throw new Error(\n        'Cannot start an audio recording without initializing a MediaRecorder. Run prepareToRecordAsync() before attempting to start an audio recording.'\n      );\n    }\n\n    // Set status to paused\n    mediaRecorder.pause();\n\n    return this.getAudioRecordingStatus();\n  },\n  async stopAudioRecording(): Promise<RecordingStatus> {\n    if (mediaRecorder === null) {\n      throw new Error(\n        'Cannot start an audio recording without initializing a MediaRecorder. Run prepareToRecordAsync() before attempting to start an audio recording.'\n      );\n    }\n\n    if (mediaRecorder.state === 'inactive') {\n      return this.getAudioRecordingStatus();\n    }\n\n    const dataPromise = new Promise((resolve) =>\n      mediaRecorder.addEventListener('dataavailable', (e) => resolve(e.data))\n    );\n\n    mediaRecorder.stop();\n\n    const data = await dataPromise;\n    const url = URL.createObjectURL(data);\n\n    return {\n      ...(await this.getAudioRecordingStatus()),\n      uri: url,\n    };\n  },\n  async unloadAudioRecorder(): Promise<void> {\n    mediaRecorder = null;\n  },\n\n  async getPermissionsAsync(): Promise<PermissionResponse> {\n    const maybeStatus = await getPermissionWithQueryAsync('microphone');\n    switch (maybeStatus) {\n      case PermissionStatus.GRANTED:\n        return {\n          status: PermissionStatus.GRANTED,\n          expires: 'never',\n          canAskAgain: true,\n          granted: true,\n        };\n      case PermissionStatus.DENIED:\n        return {\n          status: PermissionStatus.DENIED,\n          expires: 'never',\n          canAskAgain: true,\n          granted: false,\n        };\n      default:\n        return await this.requestPermissionsAsync();\n    }\n  },\n  async requestPermissionsAsync(): Promise<PermissionResponse> {\n    try {\n      const stream = await getUserMedia({ audio: true });\n      stream.getTracks().forEach((track) => track.stop());\n      return {\n        status: PermissionStatus.GRANTED,\n        expires: 'never',\n        canAskAgain: true,\n        granted: true,\n      };\n    } catch (e) {\n      return {\n        status: PermissionStatus.DENIED,\n        expires: 'never',\n        canAskAgain: true,\n        granted: false,\n      };\n    }\n  },\n};\n"]},"metadata":{},"sourceType":"module"}